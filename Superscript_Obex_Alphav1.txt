Cargo.lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "arrayvec"
version = "0.7.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7c02d123df017efcdfbd739ef81735b36c5ba83ec3c59c80a9d7ecc718f92e50"

[[package]]
name = "base64ct"
version = "1.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "55248b47b0caf0546f7988906588779981c43bb1bc9d0c44087278f80cdb44ba"

[[package]]
name = "bitvec"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bc2832c24239b0141d5674bb9174f9d68a8b5b3f2753311927c172ca46f7e9c"
dependencies = [
 "funty",
 "radium",
 "tap",
 "wyz",
]

[[package]]
name = "block-buffer"
version = "0.10.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3078c7629b62d3f0439517fa394996acacc5cbc91c5a20d8c658e77abd503a71"
dependencies = [
 "generic-array",
]

[[package]]
name = "bumpalo"
version = "3.19.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "46c5e41b57b8bba42a04676d81cb89e9ee8e859a1a66f80a5a72e1cb76b34d43"

[[package]]
name = "byte-slice-cast"
version = "1.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7575182f7272186991736b70173b0ea045398f984bf5ebbb3804736ce1330c9d"

[[package]]
name = "byteorder"
version = "1.5.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1fd0f2584146f6f2ef48085050886acf353beff7305ebd1ae69500e27c67f64b"

[[package]]
name = "cfg-if"
version = "1.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "2fd1289c04a9ea8cb22300a459a72a385d7c73d3259e2ed7dcb2af674838cfa9"

[[package]]
name = "const-oid"
version = "0.9.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c2459377285ad874054d797f3ccebf984978aa39129f6eafde5cdc8315b612f8"

[[package]]
name = "const_format"
version = "0.2.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "126f97965c8ad46d6d9163268ff28432e8f6a1196a55578867832e3049df63dd"
dependencies = [
 "const_format_proc_macros",
]

[[package]]
name = "const_format_proc_macros"
version = "0.2.34"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1d57c2eccfb16dbac1f4e61e206105db5820c9d26c3c472bc17c774259ef7744"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-xid",
]

[[package]]
name = "cpufeatures"
version = "0.2.17"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "59ed5838eebb26a2bb2e58f6d5b5316989ae9d08bab10e0e6d103e656d1b0280"
dependencies = [
 "libc",
]

[[package]]
name = "crunchy"
version = "0.2.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "460fbee9c2c2f33933d720630a6a0bac33ba7053db5344fac858d4b8952d77d5"

[[package]]
name = "crypto-common"
version = "0.1.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1bfb12502f3fc46cca1bb51ac28df9d618d813cdc3d2f25b9fe775a34af26bb3"
dependencies = [
 "generic-array",
 "typenum",
]

[[package]]
name = "curve25519-dalek"
version = "4.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "97fb8b7c4503de7d6ae7b42ab72a5a59857b4c937ec27a3d4539dba95b5ab2be"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "curve25519-dalek-derive",
 "digest",
 "fiat-crypto",
 "rustc_version",
 "subtle",
 "zeroize",
]

[[package]]
name = "curve25519-dalek-derive"
version = "0.1.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f46882e17999c6cc590af592290432be3bce0428cb0d5f8b6715e4dc7b383eb3"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "der"
version = "0.7.10"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e7c1832837b905bbfb5101e07cc24c8deddf52f93225eee6ead5f4d63d53ddcb"
dependencies = [
 "const-oid",
 "zeroize",
]

[[package]]
name = "digest"
version = "0.10.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9ed9a281f7bc9b7576e61468ba615a66a5c8cfdff42420a70aa82701a3b1e292"
dependencies = [
 "block-buffer",
 "crypto-common",
]

[[package]]
name = "ed25519"
version = "2.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "115531babc129696a58c64a4fef0a8bf9e9698629fb97e9e40767d235cfbcd53"
dependencies = [
 "pkcs8",
 "signature",
]

[[package]]
name = "ed25519-dalek"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "70e796c081cee67dc755e1a36a0a172b897fab85fc3f6bc48307991f64e4eca9"
dependencies = [
 "curve25519-dalek",
 "ed25519",
 "serde",
 "sha2",
 "subtle",
 "zeroize",
]

[[package]]
name = "equivalent"
version = "1.0.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "877a4ace8713b0bcf2a4e7eec82529c029f1d0619886d18145fea96c3ffe5c0f"

[[package]]
name = "ff"
version = "0.13.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "c0b50bfb653653f9ca9095b427bed08ab8d75a137839d9ad64eb11810d5b6393"
dependencies = [
 "rand_core",
 "subtle",
]

[[package]]
name = "fiat-crypto"
version = "0.2.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "28dea519a9695b9977216879a3ebfddf92f1c08c05d984f8996aecd6ecdc811d"

[[package]]
name = "fixed-hash"
version = "0.8.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "835c052cb0c08c1acf6ffd71c022172e18723949c8282f2b9f27efbc51e64534"
dependencies = [
 "byteorder",
 "rand",
 "rustc-hex",
 "static_assertions",
]

[[package]]
name = "funty"
version = "2.0.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6d5a32815ae3f33302d95fdcb2ce17862f8c65363dcfd29360480ba1001fc9c"

[[package]]
name = "generic-array"
version = "0.14.7"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85649ca51fd72272d7821adaf274ad91c288277713d9c18820d8499a7ff69e9a"
dependencies = [
 "typenum",
 "version_check",
]

[[package]]
name = "getrandom"
version = "0.2.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "335ff9f135e4384c8150d6f27c6daed433577f86b4750418338c01a1a2528592"
dependencies = [
 "cfg-if",
 "js-sys",
 "libc",
 "wasi",
 "wasm-bindgen",
]

[[package]]
name = "group"
version = "0.13.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f0f9ef7462f7c099f518d754361858f86d8a07af53ba9af0fe635bbccb151a63"
dependencies = [
 "ff",
 "rand_core",
 "subtle",
]

[[package]]
name = "hashbrown"
version = "0.15.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "9229cfe53dfd69f0609a49f65461bd93001ea1ef889cd5529dd176593f5338a1"

[[package]]
name = "hex"
version = "0.4.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "7f24254aa9a54b5c858eaee2f5bccdb46aaf0e486a595ed5fd8f86ba55232a70"

[[package]]
name = "hex-literal"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6fe2267d4ed49bc07b63801559be28c718ea06c4738b7a03c94df7386d2cde46"

[[package]]
name = "impl-codec"
version = "0.6.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba6a270039626615617f3f36d15fc827041df3b78c439da2cadfa47455a77f2f"
dependencies = [
 "parity-scale-codec",
]

[[package]]
name = "impl-trait-for-tuples"
version = "0.2.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a0eb5a3343abf848c0984fe4604b2b105da9539376e24fc0a3b0007411ae4fd9"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "indexmap"
version = "2.11.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "206a8042aec68fa4a62e8d3f7aa4ceb508177d9324faf261e1959e495b7a1921"
dependencies = [
 "equivalent",
 "hashbrown",
]

[[package]]
name = "js-sys"
version = "0.3.80"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "852f13bec5eba4ba9afbeb93fd7c13fe56147f055939ae21c43a29a0ecb2702e"
dependencies = [
 "once_cell",
 "wasm-bindgen",
]

[[package]]
name = "keccak"
version = "0.1.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ecc2af9a1119c51f12a14607e783cb977bde58bc069ff0c3da1095e635d70654"
dependencies = [
 "cpufeatures",
]

[[package]]
name = "libc"
version = "0.2.176"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "58f929b4d672ea937a23a1ab494143d968337a5f47e56d0815df1e0890ddf174"

[[package]]
name = "log"
version = "0.4.28"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34080505efa8e45a4b816c349525ebe327ceaa8559756f0356cba97ef3bf7432"

[[package]]
name = "memchr"
version = "2.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "32a282da65faaf38286cf3be983213fcf1d2e2a58700e808f83f4ea9a4804bc0"

[[package]]
name = "obex_alpha_i"
version = "0.1.0"
dependencies = [
 "ed25519-dalek",
 "hex",
 "hex-literal",
 "obex_primitives",
 "sha2",
 "thiserror",
 "vrf-rfc9381",
]

[[package]]
name = "obex_alpha_ii"
version = "0.1.0"
dependencies = [
 "hex",
 "obex_primitives",
 "thiserror",
]

[[package]]
name = "obex_alpha_iii"
version = "0.1.0"
dependencies = [
 "ed25519-dalek",
 "hex",
 "obex_primitives",
 "thiserror",
]

[[package]]
name = "obex_alpha_t"
version = "0.1.0"
dependencies = [
 "hex",
 "obex_primitives",
 "primitive-types",
 "thiserror",
]

[[package]]
name = "obex_primitives"
version = "0.1.0"
dependencies = [
 "hex",
 "sha3",
 "subtle",
 "thiserror",
]

[[package]]
name = "once_cell"
version = "1.21.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "42f5e15c9953c5e4ccceeb2e7382a716482c34515315f7b03532b8b4e8393d2d"

[[package]]
name = "parity-scale-codec"
version = "3.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "799781ae679d79a948e13d4824a40970bfa500058d245760dd857301059810fa"
dependencies = [
 "arrayvec",
 "bitvec",
 "byte-slice-cast",
 "const_format",
 "impl-trait-for-tuples",
 "parity-scale-codec-derive",
 "rustversion",
 "serde",
]

[[package]]
name = "parity-scale-codec-derive"
version = "3.7.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34b4653168b563151153c9e4c08ebed57fb8262bebfa79711552fa983c623e7a"
dependencies = [
 "proc-macro-crate",
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "pkcs8"
version = "0.10.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f950b2377845cebe5cf8b5165cb3cc1a5e0fa5cfa3e1f7f55707d8fd82e0a7b7"
dependencies = [
 "der",
 "spki",
]

[[package]]
name = "ppv-lite86"
version = "0.2.21"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "85eae3c4ed2f50dcfe72643da4befc30deadb458a9b590d720cde2f2b1e97da9"
dependencies = [
 "zerocopy",
]

[[package]]
name = "primitive-types"
version = "0.12.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b34d9fd68ae0b74a41b21c03c2f62847aa0ffea044eee893b4c140b37e244e2"
dependencies = [
 "fixed-hash",
 "impl-codec",
 "uint",
]

[[package]]
name = "proc-macro-crate"
version = "3.3.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "edce586971a4dfaa28950c6f18ed55e0406c1ab88bbce2c6f6293a7aaba73d35"
dependencies = [
 "toml_edit",
]

[[package]]
name = "proc-macro2"
version = "1.0.101"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "89ae43fd86e4158d6db51ad8e2b80f313af9cc74f5c0e03ccb87de09998732de"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "quote"
version = "1.0.40"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1885c039570dc00dcb4ff087a89e185fd56bae234ddc7f056a945bf36467248d"
dependencies = [
 "proc-macro2",
]

[[package]]
name = "radium"
version = "0.7.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "dc33ff2d4973d518d823d61aa239014831e521c75da58e3df4840d3f47749d09"

[[package]]
name = "rand"
version = "0.8.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "34af8d1a0e25924bc5b7c43c079c942339d8f0a8b57c39049bef581b46327404"
dependencies = [
 "libc",
 "rand_chacha",
 "rand_core",
]

[[package]]
name = "rand_chacha"
version = "0.3.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "e6c10a63a0fa32252be49d21e7709d4d4baf8d231c2dbce1eaa8141b9b127d88"
dependencies = [
 "ppv-lite86",
 "rand_core",
]

[[package]]
name = "rand_core"
version = "0.6.4"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ec0be4795e2f6a28069bec0b5ff3e2ac9bafc99e6a9a7dc3547996c5c816922c"
dependencies = [
 "getrandom",
]

[[package]]
name = "rustc-hex"
version = "2.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3e75f6a532d0fd9f7f13144f392b6ad56a32696bfcd9c78f797f16bbb6f072d6"

[[package]]
name = "rustc_version"
version = "0.4.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "cfcb3a22ef46e85b45de6ee7e79d063319ebb6594faafcf1c225ea92ab6e9b92"
dependencies = [
 "semver",
]

[[package]]
name = "rustversion"
version = "1.0.22"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "b39cdef0fa800fc44525c84ccb54a029961a8215f9619753635a9c0d2538d46d"

[[package]]
name = "semver"
version = "1.0.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d767eb0aabc880b29956c35734170f26ed551a859dbd361d140cdbeca61ab1e2"

[[package]]
name = "serde"
version = "1.0.226"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0dca6411025b24b60bfa7ec1fe1f8e710ac09782dca409ee8237ba74b51295fd"
dependencies = [
 "serde_core",
]

[[package]]
name = "serde_core"
version = "1.0.226"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ba2ba63999edb9dac981fb34b3e5c0d111a69b0924e253ed29d83f7c99e966a4"
dependencies = [
 "serde_derive",
]

[[package]]
name = "serde_derive"
version = "1.0.226"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "8db53ae22f34573731bafa1db20f04027b2d25e02d8205921b569171699cdb33"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "sha2"
version = "0.10.9"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a7507d819769d01a365ab707794a4084392c824f54a7a6a7862f8c3d0892b283"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "digest",
]

[[package]]
name = "sha3"
version = "0.10.8"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "75872d278a8f37ef87fa0ddbda7802605cb18344497949862c0d4dcb291eba60"
dependencies = [
 "digest",
 "keccak",
]

[[package]]
name = "signature"
version = "2.2.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "77549399552de45a898a580c1b41d445bf730df867cc44e6c0233bbc4b8329de"
dependencies = [
 "rand_core",
]

[[package]]
name = "spki"
version = "0.7.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "d91ed6c858b01f942cd56b37a94b3e0a1798290327d1236e4d9cf4eaca44d29d"
dependencies = [
 "base64ct",
 "der",
]

[[package]]
name = "static_assertions"
version = "1.1.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "a2eb9349b6444b326872e140eb1cf5e7c522154d69e7a0ffb0fb81c06b37543f"

[[package]]
name = "subtle"
version = "2.6.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "13c2bddecc57b384dee18652358fb23172facb8a2c51ccc10d74c157bdea3292"

[[package]]
name = "syn"
version = "2.0.106"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ede7c438028d4436d71104916910f5bb611972c5cfd7f89b8300a8186e6fada6"
dependencies = [
 "proc-macro2",
 "quote",
 "unicode-ident",
]

[[package]]
name = "tap"
version = "1.0.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "55937e1799185b12863d447f42597ed69d9928686b8d88a1df17376a097d8369"

[[package]]
name = "thiserror"
version = "2.0.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "3467d614147380f2e4e374161426ff399c91084acd2363eaf549172b3d5e60c0"
dependencies = [
 "thiserror-impl",
]

[[package]]
name = "thiserror-impl"
version = "2.0.16"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "6c5e1be1c48b9172ee610da68fd9cd2770e7a4056cb3fc98710ee6906f0c7960"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "tmp-curve25519-dalek-h2c-do-not-use"
version = "4.1.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "07e8fd0fccdf5d6baf0fa00b541d8773139c1c7dfc0094280a7d66c30d079a09"
dependencies = [
 "cfg-if",
 "cpufeatures",
 "curve25519-dalek-derive",
 "digest",
 "fiat-crypto",
 "group",
 "rand_core",
 "rustc_version",
 "subtle",
 "zeroize",
]

[[package]]
name = "toml_datetime"
version = "0.6.11"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "22cddaf88f4fbc13c51aebbf5f8eceb5c7c5a9da2ac40a13519eb5b0a0e8f11c"

[[package]]
name = "toml_edit"
version = "0.22.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "41fe8c660ae4257887cf66394862d21dbca4a6ddd26f04a3560410406a2f819a"
dependencies = [
 "indexmap",
 "toml_datetime",
 "winnow",
]

[[package]]
name = "typenum"
version = "1.18.0"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "1dccffe3ce07af9386bfd29e80c0ab1a8205a2fc34e4bcd40364df902cfa8f3f"

[[package]]
name = "uint"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "76f64bba2c53b04fcab63c01a7d7427eadc821e3bc48c34dc9ba29c501164b52"
dependencies = [
 "byteorder",
 "crunchy",
 "hex",
 "static_assertions",
]

[[package]]
name = "unicode-ident"
version = "1.0.19"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "f63a545481291138910575129486daeaf8ac54aee4387fe7906919f7830c7d9d"

[[package]]
name = "unicode-xid"
version = "0.2.6"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ebc1c04c71510c7f702b52b7c350734c9ff1295c464a03335b00bb84fc54f853"

[[package]]
name = "version_check"
version = "0.9.5"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0b928f33d975fc6ad9f86c8f283853ad26bdd5b10b7f1542aa2fa15e2289105a"

[[package]]
name = "vrf-rfc9381"
version = "0.0.3"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "caafd984b0b1857db29c26455e80d39849524e60a657892560568ed427a327b3"
dependencies = [
 "digest",
 "getrandom",
 "sha2",
 "signature",
 "subtle",
 "thiserror",
 "tmp-curve25519-dalek-h2c-do-not-use",
 "zeroize",
]

[[package]]
name = "wasi"
version = "0.11.1+wasi-snapshot-preview1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ccf3ec651a847eb01de73ccad15eb7d99f80485de043efb2f370cd654f4ea44b"

[[package]]
name = "wasm-bindgen"
version = "0.2.103"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ab10a69fbd0a177f5f649ad4d8d3305499c42bab9aef2f7ff592d0ec8f833819"
dependencies = [
 "cfg-if",
 "once_cell",
 "wasm-bindgen-macro",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-backend"
version = "0.2.103"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0bb702423545a6007bbc368fde243ba47ca275e549c8a28617f56f6ba53b1d1c"
dependencies = [
 "bumpalo",
 "log",
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-macro"
version = "0.2.103"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "fc65f4f411d91494355917b605e1480033152658d71f722a90647f56a70c88a0"
dependencies = [
 "quote",
 "wasm-bindgen-macro-support",
]

[[package]]
name = "wasm-bindgen-macro-support"
version = "0.2.103"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ffc003a991398a8ee604a401e194b6b3a39677b3173d6e74495eb51b82e99a32"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
 "wasm-bindgen-backend",
 "wasm-bindgen-shared",
]

[[package]]
name = "wasm-bindgen-shared"
version = "0.2.103"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "293c37f4efa430ca14db3721dfbe48d8c33308096bd44d80ebaa775ab71ba1cf"
dependencies = [
 "unicode-ident",
]

[[package]]
name = "winnow"
version = "0.7.13"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "21a0236b59786fed61e2a80582dd500fe61f18b5dca67a4a067d0bc9039339cf"
dependencies = [
 "memchr",
]

[[package]]
name = "wyz"
version = "0.5.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "05f360fc0b24296329c78fda852a1e9ae82de9cf7b27dae4b7f62f118f77b9ed"
dependencies = [
 "tap",
]

[[package]]
name = "zerocopy"
version = "0.8.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "0894878a5fa3edfd6da3f88c4805f4c8558e2b996227a3d864f47fe11e38282c"
dependencies = [
 "zerocopy-derive",
]

[[package]]
name = "zerocopy-derive"
version = "0.8.27"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "88d2b8d9c68ad2b9e4340d7832716a4d21a22a1154777ad56ea55c51a9cf3831"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]

[[package]]
name = "zeroize"
version = "1.8.1"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ced3678a2879b30306d323f4542626697a464a97c0a07c9aebf7ebca65cd4dde"
dependencies = [
 "zeroize_derive",
]

[[package]]
name = "zeroize_derive"
version = "1.4.2"
source = "registry+https://github.com/rust-lang/crates.io-index"
checksum = "ce36e65b0d2999d2aafac989fb249189a141aee1f53c612c1f37d72631959f69"
dependencies = [
 "proc-macro2",
 "quote",
 "syn",
]


Cargo.toml
[workspace]
members = [
    "crates/obex_primitives",
    "crates/obex_alpha_i",
    "crates/obex_alpha_ii",
    "crates/obex_alpha_iii",
    "crates/obex_alpha_t",
]
resolver = "2"

[workspace.package]
edition = "2021"
license = "MIT OR Apache-2.0"
authors = ["Obex Labs <engineering@obex.example>"]
version = "0.1.0"




obex.alpha I.txt
obex.alpha I

obex.Î± I â€” Participation Engine (VRF-salted, RAM-hard, byte-precise)

Production blueprint (byte-precise, Rust-ready pseudocode).
Role: Produce a deterministic participation set P_s per slot s, dominated by main-memory bandwidth for Sybil cost, with validator work reduced to deterministic equality checks and Merkle verifications.
Coherence:
	â€¢	Beacon: Consumes the parent slotâ€™s VDF edge y_edge_{s-1} and the parent header id parent_id from obex.Î± II.
	â€¢	Header: Exposes only P_s and the commitment part_root_s, which obex.Î± II commits into the header (field part_root).
	â€¢	Economics: P_s is consumed by obex.Î± T for rewards; no monetary logic appears in Î± I.

The specification below is normative. All tags, field orders, widths, and equality checks are exact. Independent implementations MUST agree bit-for-bit.

â¸»

1. Scope & Outputs

Per slot s:
	â€¢	P_s â€” the lexicographically sorted vector of 32-byte public keys that submitted exactly one valid proof bound to slot s.
	â€¢	part_root_s â€” binary Merkle root over P_s leaves with deterministic payload (see Â§8).

Pipeline alignment:
	â€¢	Proving (participants): During settlement of slot sâˆ’1 (~100â€“1000 ms), fill labels in RAM, compute root, open Q challenges, sign, submit ObexPartRec targeting slot = s.
	â€¢	Verification (validators): During finality of slot s (0â€“100 ms), verify proofs, deduplicate per pk, sort, materialize P_s and part_root_s.

â¸»

2. Consensus Constants

OBEX_ALPHA_I_VERSION = 1

MEM_MIB            = 512                 // target RAM per prover instance
LABEL_BYTES        = 32                  // SHA3-256 width
N_LABELS           = (MEM_MIB * 2^20) / LABEL_BYTES
                   = 512 * 1,048,576 / 32
                   = 16,777,216          // 2^24 labels

PASSES             = 3                   // diffusion passes
DEPS               = 2                   // parents per update (J,K)
CHALLENGES_Q       = 96                  // residual cheat â‰ˆ 2^-96
MERKLE_ARITY       = 2                   // binary (duplicate last if odd)

MAX_PARTREC_SIZE   = 600,000 bytes       // DoS cap on serialized proof
MAX_SUBMISSIONS_PK = 1                   // one submission per (slot, pk)

Deployments MAY additionally publish a â€œLiteâ€ parameter set (e.g., MEM_MIB=256, PASSES=2). Any variation MUST be consensus-versioned (not mixed).

â¸»

3. Hashing, Encodings, and Tags (Normative)
	â€¢	Integer encoding: Little-endian, fixed-width only. LE(x, W) emits exactly W bytes. No overlong encodings.
	â€¢	Hash type: Hash256 = [u8; 32].

Domain-tagged SHA3-256 with length framing:

H(tag_ascii, parts[]) =
    SHA3_256( UTF8(tag_ascii) || Î£ ( LE(|p|,8) || p ) )

Binary Merkle (duplicate last on odd):
	â€¢	Leaf: H("obex.merkle.leaf", payload)
	â€¢	Node: H("obex.merkle.node", L || R)
	â€¢	Empty: H("obex.merkle.empty", [])

Normative ASCII tags (exact):

"obex.alpha"     "obex.vrfy"       "obex.seed"      "obex.partrec"
"obex.l0"        "obex.lbl"        "obex.idx"       "obex.chal"
"obex.part.leaf" "obex.merkle.leaf" "obex.merkle.node" "obex.merkle.empty"

Signature & VRF:
	â€¢	Signature: Ed25519, 32-byte public key, 64-byte canonical signature (unique, non-malleable encoding).
	â€¢	VRF: ECVRF over edwards25519 per RFC 9381 (ECVRF-EDWARDS25519-SHA512-TAI). Proof bytes vrf_pi are the RFCâ€™s canonical encoding. Verifier result vrf_y MUST be 64 bytes (RFC output).

â¸»

4. RAM-Hard Label Function (Memory-Dominant)

Let seed_s be the per-slot, per-key seed (defined in Â§6). Define the label array L[0..N-1]:
	â€¢	L[0] = H("obex.l0", [seed_s])
	â€¢	For each pass p âˆˆ {0..PASSESâˆ’1} and index i âˆˆ {1..Nâˆ’1}:

J(i,p) = U64LE( H("obex.idx", [seed_s, LE(i,8), LE(p,4), 0x00])[0..8] ) % i
K(i,p) = U64LE( H("obex.idx", [seed_s, LE(i,8), LE(p,4), 0x01])[0..8] ) % i

L[i] := H("obex.lbl", [seed_s, LE(i,8), L[i-1], L[J(i,p)], L[K(i,p)]])



Performance note (informative): Each update reads 3Ã—32 B and writes 32 B (~128 B). With N=2^24, traffic is â‰ˆ2 GiB per pass â†’ â‰ˆ6 GiB total (3 passes). This enforces main-memory bandwidth dominance.

â¸»

5. Merkle Commitment (Over Raw 32-byte Labels)

root = MerkleRoot( leaves = [ L[0], L[1], â€¦, L[N-1] ] )

Each leaf payload is exactly the 32-byte label L[i] (no length prefix at payload level; the leaf hash domain tags it).

â¸»

6. Binding, VRF Input, and Deterministic Challenges

6.1 VRF input Î± (slot- and identity-bound)

Given parent_id = header_id(parent) and y_edge_{s-1} = parent.vdf_y_edge from obex.Î± II, and a proverâ€™s VRF public key vrf_pk:

alpha = H("obex.alpha", [
  parent_id,            // 32
  LE(slot,8),           // target slot s
  y_edge_{s-1},         // 32
  vrf_pk                // 32
]) // 32 bytes (Hash256)

Prover computes (vrf_y, vrf_pi) = ECVRF.Prove(vrf_sk, alpha). Verifiers MUST check ECVRF.Verify(vrf_pk, alpha, vrf_pi) â†’ vrf_y.

6.2 Seed derivation (per-slot, per-key)

To couple VRF personalization with RAM hardness:

seed_s = H("obex.seed", [ y_edge_{s-1}, pk_ed25519, vrf_y ])

This pins all label work to the parentâ€™s beacon and the proverâ€™s identity+VRF output (no grinding surface once alpha is fixed).

6.3 Challenge indices

For t âˆˆ {0..CHALLENGES_Qâˆ’1}:

i_t = 1 + ( U64LE( H("obex.chal",
         [ y_edge_{s-1}, root, vrf_y, LE(t,4) ])[0..8] ) % (N_LABELS - 1) )

Indices are in [1..Nâˆ’1] so iâˆ’1 exists for the label equation.

â¸»

7. Transcript, Signature, and Proof Object

7.1 Canonical transcript to sign

msg = H("obex.partrec", [
  LE(OBEX_ALPHA_I_VERSION,4),
  pk_ed25519,           // 32
  vrf_pk,               // 32
  LE(slot,8),
  y_edge_{s-1},         // 32
  alpha,                // 32 (as defined in Â§6.1)
	vrf_y,                // 64 (RFC output)
  root                  // 32
])

sig = Sign_Ed25519(sk_ed25519, msg)  // 64 bytes canonical

7.2 Canonical proof object (ObexPartRec)

ObexPartRec {
  version      : u32           // == OBEX_ALPHA_I_VERSION
  slot         : u64
  pk_ed25519   : [u8; 32]
  vrf_pk       : [u8; 32]
  y_edge_prev  : Hash256       // == y_edge_{s-1}
  alpha        : Hash256       // H("obex.alpha", [...]) (32)
	vrf_y        : [u8; 64]      // RFC 9381 output
  vrf_pi       : [u8; 80]      // RFC 9381 canonical proof bytes
  seed         : Hash256       // == H("obex.seed", [y_edge_prev, pk_ed25519, vrf_y])
  root         : Hash256       // Merkle root over labels

  challenges   : Vec<Challenge>  // length-prefixed LE(4); len == CHALLENGES_Q

  sig          : [u8; 64]      // Ed25519 over msg
}

Each Challenge (canonical order of fields):

Challenge {
  idx   : u64          // LE(8) == i_t
  li    : [u8; 32]     // L[i]
  pi    : Vec<Hash256> // LE(4) len; Merkle path for index i (leafâ†’root)

  lim1  : [u8; 32]     // L[i-1]
  pim1  : Vec<Hash256> // path for (i-1)

  lj    : [u8; 32]     // L[J(i, p_last)]
  pj    : Vec<Hash256>

  lk    : [u8; 32]     // L[K(i, p_last)]
  pk_   : Vec<Hash256> // named 'pk_' to avoid colliding with pk_ed25519
}

Serialization (normative): Exactly the field order above.
All variable-length vectors are encoded as LE(len,4) || concatenated elements.
The serialized byte length of ObexPartRec MUST NOT exceed MAX_PARTREC_SIZE. Enforce this before expensive verification.

â¸»

8. Participation Set and Commitment

Deduplication & sort:
	â€¢	Accept at most one valid ObexPartRec per (slot, pk_ed25519) (first valid wins; later ones ignored).
	â€¢	Sort accepted pk ascending (raw 32-byte lexicographic order).

Leaf payload and root:

part_leaf(pk)  = H("obex.part.leaf",[]) || pk
part_root_s    = MerkleRoot( leaves = [ part_leaf(pk) for pk in P_s ] )

Only P_s and part_root_s are exposed to other engines.

â¸»

9. Verifier Algorithm (Deterministic Equality Checks)

To validate a received ObexPartRec r for target slot s:
	1.	Structure & size checks
	â€¢	r.version == OBEX_ALPHA_I_VERSION
	â€¢	r.slot == s
	â€¢	|r| â‰¤ MAX_PARTREC_SIZE
	â€¢	len(r.challenges) == CHALLENGES_Q
	2.	VRF verification
	â€¢	Recompute alpha = H("obex.alpha", [parent_id, LE(s,8), r.y_edge_prev, r.vrf_pk])
	â€¢	Verify ECVRF.Verify(r.vrf_pk, alpha, r.vrf_pi) â†’ vrf_y_check
	â€¢	If using 32-byte rehash: vrf_y_expected = H("obex.vrfy",[vrf_y_check]); else compare 64 bytes.
	â€¢	Reject if r.vrf_y != vrf_y_expected.
	3.	Seed equality
	â€¢	seed_expected = H("obex.seed", [ r.y_edge_prev, r.pk_ed25519, r.vrf_y ])
	â€¢	Reject if r.seed != seed_expected.
	4.	Transcript signature
	â€¢	Rebuild msg = H("obex.partrec", [...]) as in Â§7.1 using the values inside r.
	â€¢	Verify Ed25519.Verify(r.pk_ed25519, msg, r.sig) == true.
	5.	Per-challenge checks (last pass p_last = PASSES âˆ’ 1)
For each t in 0..Qâˆ’1 with ch = r.challenges[t]:
	â€¢	i_expected = 1 + ( U64LE( H("obex.chal",[ r.y_edge_prev, r.root, r.vrf_y, LE(t,4) ])[0..8] ) % (N_LABELS âˆ’ 1) )
	â€¢	Reject if ch.idx != i_expected.
	â€¢	Compute j = J(i_expected, p_last) and k = K(i_expected, p_last) using r.seed and Â§4 definitions; require 1 â‰¤ i_expected < N, j < i_expected, k < i_expected.
	â€¢	Verify Merkle paths under r.root for:
	â€¢	ch.li at index i_expected,
	â€¢	ch.lim1 at index i_expected âˆ’ 1,
	â€¢	ch.lj at index j,
	â€¢	ch.lk at index k.
	â€¢	Recompute the last-pass label equation:

li_check = H("obex.lbl", [ r.seed, LE(i_expected,8), ch.lim1, ch.lj, ch.lk ])

Reject if li_check != ch.li.

	6.	Accept
	â€¢	If all checks pass, accept one submission for (s, r.pk_ed25519).

All equality and 32-byte hash comparisons MUST use constant-time comparisons.

â¸»

10. Rust-Ready Module (Consensus-Critical Pseudocode)

Replace cryptographic stubs with real libraries: SHA3-256, Ed25519 (canonical), ECVRF (RFC 9381). Do not alter encodings, tags, or order.

// ========================== obex_alpha_i.rs ===========================
// obex.Î± I â€” Participation Engine (VRF-salted, RAM-hard, byte-precise)
// =====================================================================

#![allow(unused)]
use alloc::vec::Vec;
use alloc::collections::{BTreeSet};

// â€”â€”â€” Types â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
pub type Hash256 = [u8; 32];
pub type PK      = [u8; 32]; // Ed25519 public key
pub type VRFPK   = [u8; 32];
pub type Sig     = [u8; 64]; // Ed25519 canonical signature

// â€”â€”â€” Integer encodings â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
#[inline]
pub fn le_bytes<const W: usize>(mut x: u128) -> [u8; W] {
    let mut out = [0u8; W];
    for i in 0..W { out[i] = (x & 0xFF) as u8; x >>= 8; }
    out
}

pub fn u64_from_le(b: &[u8]) -> u64 {
    let mut x: u64 = 0;
    for (i, &bi) in b.iter().take(8).enumerate() { x |= (bi as u64) << (8*i); }
    x
}

// â€”â€”â€” Hashing (domain-tagged SHA3-256; length-framed) â€”â€”â€”â€”â€”â€”â€”â€”
pub fn sha3_256(_input: &[u8]) -> Hash256 { unimplemented!() }

pub fn h_tag(tag: &str, parts: &[&[u8]]) -> Hash256 {
    let mut buf = Vec::new();
    buf.extend_from_slice(tag.as_bytes());
    for p in parts {
        buf.extend_from_slice(&le_bytes::<8>(p.len() as u128));
        buf.extend_from_slice(p);
    }
    sha3_256(&buf)
}

// â€”â€”â€” Merkle (binary; duplicate last when odd) â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
#[inline] pub fn merkle_leaf(payload: &[u8]) -> Hash256 { h_tag("obex.merkle.leaf", &[payload]) }

#[inline]
pub fn merkle_node(l: &Hash256, r: &Hash256) -> Hash256 {
    let mut cat = [0u8; 64];
    cat[..32].copy_from_slice(l);
    cat[32..].copy_from_slice(r);
    h_tag("obex.merkle.node", &[&cat])
}

pub fn merkle_root(leaves_payload: &[Vec<u8>]) -> Hash256 {
    if leaves_payload.is_empty() { return h_tag("obex.merkle.empty", &[]); }
    let mut level: Vec<Hash256> = leaves_payload.iter().map(|p| merkle_leaf(p)).collect();
    while level.len() > 1 {
        if level.len() % 2 == 1 { level.push(*level.last().unwrap()); }
        let mut next = Vec::with_capacity(level.len()/2);
        for i in (0..level.len()).step_by(2) { next.push(merkle_node(&level[i], &level[i+1])); }
        level = next;
    }
    level[0]
}

pub struct MerklePath { pub siblings: Vec<Hash256>, pub index: u64 }

pub fn merkle_verify_leaf(root: &Hash256, leaf_payload: &[u8], path: &MerklePath) -> bool {
    let mut h = merkle_leaf(leaf_payload);
    let mut idx = path.index;
    for sib in &path.siblings {
        if idx & 1 == 0 { h = merkle_node(&h, sib); } else { h = merkle_node(sib, &h); }
        idx >>= 1;
    }
    &h == root
}

// â€”â€”â€” Crypto stubs â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// Replace with real Ed25519 and ECVRF (RFC 9381).
pub fn verify_sig(_pk: &PK, _msg: &Hash256, _sig: &Sig) -> bool { unimplemented!() }
pub fn ecvrf_verify(_vrf_pk: &VRFPK, _alpha: &Hash256, _vrf_pi: &[u8]) -> Option<Vec<u8>> {
    // Return Some(vrf_y_bytes) on success (RFC 9381 output), else None.
    unimplemented!()
}

// â€”â€”â€” Constants â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
pub const OBEX_ALPHA_I_VERSION: u32 = 1;
pub const MEM_MIB: usize       = 512;
pub const LABEL_BYTES: usize   = 32;
pub const N_LABELS: usize      = (MEM_MIB * 1024 * 1024) / LABEL_BYTES; // 16,777,216
pub const PASSES: u32          = 3;
pub const CHALLENGES_Q: usize  = 96;
pub const MAX_PARTREC_SIZE: usize = 600_000;

// â€”â€”â€” Seed, indices, label update â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
#[inline] pub fn obex_alpha(parent_id: &Hash256, slot: u64, y_prev: &Hash256, vrf_pk: &VRFPK) -> Hash256 {
    h_tag("obex.alpha", &[parent_id, &le_bytes::<8>(slot as u128), y_prev, vrf_pk])
}
#[inline] pub fn obex_seed(y_prev: &Hash256, pk: &PK, vrf_y: &[u8]) -> Hash256 {
    h_tag("obex.seed", &[y_prev, pk, vrf_y])
}
#[inline] fn lbl0(seed: &Hash256) -> Hash256 { h_tag("obex.l0", &[seed]) }

#[inline]
fn idx_j(seed: &Hash256, i: u64, p: u32) -> u64 {
    let b = h_tag("obex.idx", &[seed, &le_bytes::<8>(i as u128), &le_bytes::<4>(p as u128), &[0x00]]);
    if i == 0 { 0 } else { u64_from_le(&b[..8]) % i }
}
#[inline]
fn idx_k(seed: &Hash256, i: u64, p: u32) -> u64 {
    let b = h_tag("obex.idx", &[seed, &le_bytes::<8>(i as u128), &le_bytes::<4>(p as u128), &[0x01]]);
    if i == 0 { 0 } else { u64_from_le(&b[..8]) % i }
}

#[inline]
fn label_update(seed: &Hash256, i: u64, l_im1: &Hash256, l_j: &Hash256, l_k: &Hash256) -> Hash256 {
    h_tag("obex.lbl", &[seed, &le_bytes::<8>(i as u128), l_im1, l_j, l_k])
}

// â€”â€”â€” Prover array fill â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
pub struct ProverArray { pub labels: Vec<Hash256> }

impl ProverArray {
    pub fn fill(seed: &Hash256) -> Self {
        let mut labels = Vec::with_capacity(N_LABELS);
        labels.push(lbl0(seed));
        // pass 0
        for i in 1..N_LABELS {
            let j = idx_j(seed, i as u64, 0) as usize;
            let k = idx_k(seed, i as u64, 0) as usize;
            labels.push(label_update(seed, i as u64, &labels[i-1], &labels[j], &labels[k]));
        }
        // passes 1..PASSES-1
        for p in 1..PASSES {
            for i in 1..N_LABELS {
                let j = idx_j(seed, i as u64, p) as usize;
                let k = idx_k(seed, i as u64, p) as usize;
                labels[i] = label_update(seed, i as u64, &labels[i-1], &labels[j], &labels[k]);
            }
        }
        Self { labels }
    }
    pub fn merkle_root(&self) -> Hash256 {
        let mut payloads = Vec::with_capacity(N_LABELS);
        for l in &self.labels { payloads.push(l.to_vec()); }
        merkle_root(&payloads)
    }
}

// â€”â€”â€” Challenge index â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
fn chal_index(y_prev: &Hash256, root: &Hash256, vrf_y: &[u8], t: u32) -> u64 {
    let b = h_tag("obex.chal", &[y_prev, root, vrf_y, &le_bytes::<4>(t as u128)]);
    1 + (u64_from_le(&b[..8]) % ((N_LABELS as u64) - 1))
}

// â€”â€”â€” Transcript hash â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
fn partrec_msg(
    version: u32, slot: u64, pk: &PK, vrf_pk: &VRFPK,
    y_prev: &Hash256, alpha: &Hash256, vrf_y: &[u8], root: &Hash256
) -> Hash256 {
    h_tag("obex.partrec", &[
        &le_bytes::<4>(version as u128),
        pk, vrf_pk, &le_bytes::<8>(slot as u128),
        y_prev, alpha, vrf_y, root
    ])
}

// â€”â€”â€” Canonical types â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
#[derive(Clone)]
pub struct MerklePathLite { pub siblings: Vec<Hash256> } // index supplied alongside

#[derive(Clone)]
pub struct ChallengeOpen {
    pub idx:  u64,
    pub li:   Hash256,
    pub pi:   MerklePathLite,

    pub lim1: Hash256,
    pub pim1: MerklePathLite,

    pub lj:   Hash256,
    pub pj:   MerklePathLite,

    pub lk:   Hash256,
    pub pk_:  MerklePathLite,
}

pub struct ObexPartRec {
    pub version: u32,
    pub slot:    u64,
    pub pk_ed25519: PK,
    pub vrf_pk:     VRFPK,
    pub y_edge_prev: Hash256,
    pub alpha:   Hash256,
    pub vrf_y:   Vec<u8>,   // 64 or 32 bytes (network-wide fixed)
    pub vrf_pi:  Vec<u8>,   // RFC 9381
    pub seed:    Hash256,
    pub root:    Hash256,
    pub challenges: Vec<ChallengeOpen>, // len == CHALLENGES_Q
    pub sig:     Sig,
}

// â€”â€”â€” Verify function â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
pub fn obex_verify_partrec(
    rec: &ObexPartRec,
    slot: u64,
    parent_id: &Hash256,
) -> bool {
    if rec.version != OBEX_ALPHA_I_VERSION { return false; }
    if rec.slot != slot { return false; }
    if rec.challenges.len() != CHALLENGES_Q { return false; }

    // 1) VRF
    let alpha = obex_alpha(parent_id, slot, &rec.y_edge_prev, &rec.vrf_pk);
    if alpha != rec.alpha { return false; }
    let vrf_y_check = match ecvrf_verify(&rec.vrf_pk, &alpha, &rec.vrf_pi) { Some(y) => y, None => return false };
    if vrf_y_check.as_slice() != rec.vrf_y.as_slice() { return false; } // or compare to H("obex.vrfy",[...]) if 32-byte mode

    // 2) Seed
    let seed_expected = obex_seed(&rec.y_edge_prev, &rec.pk_ed25519, &rec.vrf_y);
    if seed_expected != rec.seed { return false; }

    // 3) Signature
    let msg = partrec_msg(rec.version, rec.slot, &rec.pk_ed25519, &rec.vrf_pk,
                          &rec.y_edge_prev, &rec.alpha, &rec.vrf_y, &rec.root);
    if !verify_sig(&rec.pk_ed25519, &msg, &rec.sig) { return false; }

    // 4) Challenges
    let last_pass = PASSES - 1;
    for (t, ch) in rec.challenges.iter().enumerate() {
        let i = chal_index(&rec.y_edge_prev, &rec.root, &rec.vrf_y, t as u32);
        if ch.idx != i { return false; }
        if !(i > 0 && (i as usize) < N_LABELS) { return false; }

        let j = idx_j(&rec.seed, i, last_pass);
        let k = idx_k(&rec.seed, i, last_pass);
        if !(j < i && k < i) { return false; }

        // Merkle paths
        if !merkle_verify_leaf(&rec.root, &ch.li,   &MerklePath { siblings: ch.pi.siblings.clone(),   index: i }) { return false; }
        if !merkle_verify_leaf(&rec.root, &ch.lim1, &MerklePath { siblings: ch.pim1.siblings.clone(), index: i-1 }) { return false; }
        if !merkle_verify_leaf(&rec.root, &ch.lj,   &MerklePath { siblings: ch.pj.siblings.clone(),   index: j }) { return false; }
        if !merkle_verify_leaf(&rec.root, &ch.lk,   &MerklePath { siblings: ch.pk_.siblings.clone(),  index: k }) { return false; }

        // Label equation
        let li_check = label_update(&rec.seed, i, &ch.lim1, &ch.lj, &ch.lk);
        if li_check != ch.li { return false; }
    }
    true
}

// â€”â€”â€” Participation set & commitment â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
pub fn build_participation_set<'a>(
    slot: u64,
    parent_id: &Hash256,
    submissions: impl Iterator<Item=&'a ObexPartRec>
) -> (Vec<PK>, Hash256) {
    let mut seen: BTreeSet<PK> = BTreeSet::new();
    let mut pks: Vec<PK> = Vec::new();

    for rec in submissions {
        if rec.slot != slot { continue; }
        if seen.contains(&rec.pk_ed25519) { continue; }
        if obex_verify_partrec(rec, slot, parent_id) {
            seen.insert(rec.pk_ed25519);
            pks.push(rec.pk_ed25519);
        }
    }
    pks.sort(); // lexicographic

    // part_root = Merkle over H("obex.part.leaf",[]) || pk
    let leaves: Vec<Vec<u8>> = pks.iter().map(|pk| {
        let mut b = Vec::with_capacity(32+32);
        b.extend_from_slice(&h_tag("obex.part.leaf", &[]));
        b.extend_from_slice(pk);
        b
    }).collect();
    let part_root = merkle_root(&leaves);

    (pks, part_root)
}


â¸»

11. Resource Profile (Reference)
	â€¢	Prover: â‰ˆ6 GiB RAM traffic (3 passes) with MEM_MIB=512, contiguous 512 MiB for labels plus overhead for Merkle path extraction.
	â€¢	Verifier: Q Ã— (4 Ã— log2(N)) Merkle nodes + constant label checks. For Q=96, N=2^24, ~9,216 node hashes â†’ within 0â€“100 ms on commodity hardware with optimized SHA3.
	â€¢	Network: Typical ObexPartRec â‰ˆ300 KiB; enforce MAX_PARTREC_SIZE early.

â¸»

12. Implementation Guidance (Consensus-Safety)
	â€¢	Hashing: Use vetted SHA3-256; do not deviate from tag strings or length framing.
	â€¢	ECVRF: RFC 9381, canonical proof bytes; fail-closed on any ambiguity.
	â€¢	Signatures: Ed25519 with unique encoding (no DER); constant-time verification.
	â€¢	Merkle paths: Binary; duplicate last when odd; constant-time hash compares.
	â€¢	Streaming: Production provers SHOULD avoid building full trees; retain minimal nodes for paths or use streaming-level construction.
	â€¢	DoS: Enforce MAX_PARTREC_SIZE and CHALLENGES_Q exactly; ignore later submissions per (slot, pk) after first valid.

â¸»

13. Conformance Checklist (Engineer-Facing)
	â€¢	Integers are LE fixed-width (u32, u64), vector lengths LE(4).
	â€¢	Tags exactly as listed (Â§3).
	â€¢	VRF input alpha = H("obex.alpha",[parent_id, LE(slot,8), y_edge_{s-1}, vrf_pk]).
	â€¢	VRF proof verifies; vrf_y matches canonical form (64 bytes).
	â€¢	Seed H("obex.seed",[y_edge_{s-1}, pk_ed25519, vrf_y]).
	â€¢	Labels per Â§4 with PASSES=3, DEPS=2.
	â€¢	Merkle over raw 32-byte labels; binary; duplicate last; empty root tag.
	â€¢	Challenges i_t from H("obex.chal",[y_prev, root, vrf_y, LE(t,4)]), t=0..Qâˆ’1, indices in [1..Nâˆ’1].
	â€¢	Proof object field order & lengths exact; serialized length â‰¤ MAX_PARTREC_SIZE.
	â€¢	Signature over H("obex.partrec",[â€¦]) with Ed25519 canonical encoding.
	â€¢	Participation: one valid submission per (slot, pk); P_s sorted; part_root_s Merkle over H("obex.part.leaf",[]) || pk.

â¸»

14. Test Vectors (Ship with Implementations)
	1.	Nominal round-trip
	â€¢	Inputs: fixed parent_id, y_edge_{s-1}, slot, pk_ed25519/vrf_pk with fixed keys.
	â€¢	Outputs: alpha, vrf_y, seed_s, first 16 labels, root, all i_t, serialized ObexPartRec bytes, P_s, part_root_s.
	2.	VRF tamper
	â€¢	Modify 1 bit in vrf_pi â†’ VRF verify fails.
	3.	Challenge corruption
	â€¢	Flip one byte of li in a challenge â†’ label equality fails.
	4.	Merkle path tamper
	â€¢	Replace a sibling hash â†’ Merkle verification fails.
	5.	Duplicate submission
	â€¢	Two proofs for same (slot, pk); only first valid is accepted.
	6.	Oversize proof
	â€¢	Serialized ObexPartRec > MAX_PARTREC_SIZE â†’ reject before crypto.

â¸»

15. Public API Summary
	â€¢	Prover (reference):
ProverArray::fill(seed: &Hash256) -> ProverArray
(non-consensus guidance for label/commit generation)
	â€¢	Verifier (per proof):
obex_verify_partrec(rec: &ObexPartRec, slot: u64, parent_id: &Hash256) -> bool
	â€¢	Builder (per slot):
build_participation_set(slot: u64, parent_id: &Hash256, submissions: impl Iterator<Item=&ObexPartRec>) -> (Vec<PK>, Hash256)

These are sufficient to integrate obex.Î± I with the nodeâ€™s pipeline and with obex.Î± II/obex.Î± T.

â¸»

This obex.Î± I blueprint is complete and byte-precise.
It specifies exact encodings, deterministic algorithms, and a production-ready Rust-style module. Independent implementations that adhere to this document will agree bit-for-bit on participation validity, P_s, and part_root_s for every slot.

obex.alpha II.txt
obex.alpha II

obex.Î± II â€” Deterministic Header Engine (forkless by equalities)

Production blueprint (byte-precise, Rust-ready pseudocode).
Role: Build and validate the unique canonical header Header_s for slot s by checking pure equalities against deterministic commitments produced by other Î±-modules.
Consumes:
	â€¢	From obex.Î± I: part_root_s (commitment to participation set P_s).
	â€¢	From Beacon (VDF): y_edge_s plus canonical proof bytes (vdf_pi, vdf_ell).
	â€¢	From obex.Î± III: ticket_root_s (admissions in s), txroot_{s-1} (executions in sâˆ’1).
Produces:
	â€¢	Header_s and its immutable obex_header_id.
	â€¢	Forklessness: at most one header satisfies all equalities for a fixed (parent, s).

All tags, field orders, lengths, and comparisons below are normative. Independent implementations MUST agree bit-for-bit.

â¸»

1. Hashing, Encodings, and Merkle (normative)

Integers: little-endian fixed width only. LE(x, W) emits exactly W bytes (no overlong encodings).
Hash type: Hash256 = [u8; 32].

Domain-tagged SHA3-256 with length framing (global discipline):

H(tag_ascii, parts[]) =
    SHA3_256( UTF8(tag_ascii) || Î£ ( LE(|p|,8) || p ) )

Binary Merkle (duplicate last when odd):
	â€¢	Leaf: H("obex.merkle.leaf", payload)
	â€¢	Node: H("obex.merkle.node", L || R)
	â€¢	Empty: H("obex.merkle.empty", [])

Canonical leaf payload tags used by Î± II:

"obex.txid.leaf"    // leaves over executed txids
"obex.ticket.leaf"  // leaves over TicketRecords (Î± III)

Header/Beacon/Seed tags used by Î± II:

"obex.header.id"   "obex.slot.seed"   "obex.vdf.ycore"   "obex.vdf.edge"

Any byte change to tag strings alters consensus. These ASCII tags are exact.

â¸»

2. Consensus Constants

OBEX_ALPHA_II_VERSION = 2      // includes part_root field and obex.* tag space

OBEX_ALPHA_II_VERSION MUST be enforced at validation time.

â¸»

3. Inter-Module Coherence (deterministic providers)
	â€¢	Beacon (VDF)
Canonical seed for slot s:

seed_s = H("obex.slot.seed", [ parent_id, LE(s,8) ])

The beacon adapter verifies the backend proof and returns:
	â€¢	vdf_y_core = H("obex.vdf.ycore", [ Y_raw ])
	â€¢	vdf_y_edge = H("obex.vdf.edge",  [ vdf_y_core ])
plus bounded byte arrays (vdf_pi, vdf_ell).

	â€¢	obex.Î± I (Participation)
Verifier recomputes P_s and part_root_s from ObexPartRecs for target slot s. (Î± II only consumes part_root_s.)
	â€¢	obex.Î± III (Admission/Execution)
Deterministically recompute:
	â€¢	ticket_root_s from canonical TicketRecord set for s.
	â€¢	txroot_{s-1} from executed txids of sâˆ’1.

Î± II does not execute or admit; it only validates equalities against these deterministic results.

â¸»

4. Header Object (canonical fields & order)

Header {
  parent_id         : Hash256         // == obex_header_id(parent)
  slot              : u64             // == parent.slot + 1
  obex_version      : u32             // == OBEX_ALPHA_II_VERSION

  // Beacon commitments (VDF)
  seed_commit       : Hash256         // == H("obex.slot.seed",[parent_id, LE(slot,8)])
  vdf_y_core        : Hash256         // == H("obex.vdf.ycore", [Y_raw])
  vdf_y_edge        : Hash256         // == H("obex.vdf.edge", [vdf_y_core])
  vdf_pi            : Bytes           // opaque; length-prefixed
  vdf_ell           : Bytes           // opaque; length-prefixed

  // Deterministic commitments (other Î± modules)
  ticket_root       : Hash256         // Î± III (slot s)
  part_root         : Hash256         // Î± I   (slot s)
  txroot_prev       : Hash256         // Î± III (slot s-1)
}

4.1 Wire serialization (normative layout)

serialize_header(h):
  bytes = []
  bytes += h.parent_id                        // 32
  bytes += LE(h.slot,8)                       // 8
  bytes += LE(h.obex_version,4)               // 4

  bytes += h.seed_commit                      // 32
  bytes += h.vdf_y_core                       // 32
  bytes += h.vdf_y_edge                       // 32
  bytes += LE(|h.vdf_pi|,4)  || h.vdf_pi[..]  // 4 + |pi|
  bytes += LE(|h.vdf_ell|,4) || h.vdf_ell[..] // 4 + |ell|

  bytes += h.ticket_root                      // 32
  bytes += h.part_root                        // 32
  bytes += h.txroot_prev                      // 32

4.2 Immutable header ID (consensus identity)

obex_header_id(h) = H("obex.header.id", [
  h.parent_id,
  LE(h.slot,8),
  LE(h.obex_version,4),

  h.seed_commit, h.vdf_y_core, h.vdf_y_edge,
  LE(|h.vdf_pi|,4),  h.vdf_pi,
  LE(|h.vdf_ell|,4), h.vdf_ell,

  h.ticket_root,
  h.part_root,
  h.txroot_prev
])

The ID is over field values, not the transport bytes, and is therefore stable across encoders that obey Â§4.1.

â¸»

5. Validity Equalities (all MUST hold)

For candidate header h and known parent:
	1.	Parent linkage & slot progression
	â€¢	h.parent_id == obex_header_id(parent)
	â€¢	h.slot      == parent.slot + 1
	2.	Beacon equality & size caps (via adapter)
	â€¢	h.seed_commit == H("obex.slot.seed",[h.parent_id, LE(h.slot,8)])
	â€¢	beacon.verify(h.parent_id, h.slot, h.seed_commit, h.vdf_y_core, h.vdf_y_edge, h.vdf_pi, h.vdf_ell) returns true and enforces |vdf_pi| â‰¤ MAX_PI_LEN, |vdf_ell| â‰¤ MAX_ELL_LEN.
	3.	Admission equality (slot s via Î± III)
	â€¢	h.ticket_root == ticket_roots.compute_ticket_root(h.slot)
	4.	Participation equality (slot s via Î± I)
	â€¢	h.part_root == part_roots.compute_part_root(h.slot)
	5.	Execution equality (slot sâˆ’1 via Î± III)
	â€¢	h.txroot_prev == tx_roots.compute_txroot(h.slot âˆ’ 1)
	â€¢	For genesis slot S0: h.txroot_prev == TXROOT_GENESIS (constant).
	6.	Version equality
	â€¢	h.obex_version == OBEX_ALPHA_II_VERSION

Any failure â‡’ header invalid. Since all RHS values are unique deterministic functions of (parent, s), at most one Header_s can satisfy all equalities (forklessness).

â¸»

6. Rust-Ready Module (byte-precise pseudocode)

Replace sha3_256 and the beacon adapter with real implementations. All encodings and field orders are normative.

// ========================= obex_alpha_ii.rs ==========================
// obex.Î± II â€” Deterministic Header Engine (forkless by equalities)
// ====================================================================

#![allow(unused)]
use alloc::vec::Vec;

// â€”â€”â€” Types â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
pub type Hash256 = [u8; 32];

// â€”â€”â€” Integer encodings â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
#[inline]
pub fn le_bytes<const W: usize>(mut x: u128) -> [u8; W] {
    let mut out = [0u8; W];
    for i in 0..W { out[i] = (x & 0xFF) as u8; x >>= 8; }
    out
}

// â€”â€”â€” Hashing (domain-tagged, length-framed) â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
pub fn sha3_256(_input: &[u8]) -> Hash256 { unimplemented!() }

#[inline]
pub fn h_tag(tag: &str, parts: &[&[u8]]) -> Hash256 {
    let mut buf = Vec::new();
    buf.extend_from_slice(tag.as_bytes());
    for p in parts {
        buf.extend_from_slice(&le_bytes::<8>(p.len() as u128));
        buf.extend_from_slice(p);
    }
    sha3_256(&buf)
}

// â€”â€”â€” Merkle helpers (shared tags) â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
#[inline] pub fn merkle_leaf(payload: &[u8]) -> Hash256 { h_tag("obex.merkle.leaf", &[payload]) }
#[inline]
pub fn merkle_node(l: &Hash256, r: &Hash256) -> Hash256 {
    let mut cat = [0u8; 64];
    cat[..32].copy_from_slice(l);
    cat[32..].copy_from_slice(r);
    h_tag("obex.merkle.node", &[&cat])
}
pub fn merkle_root(leaves_payload: &[Vec<u8>]) -> Hash256 {
    if leaves_payload.is_empty() { return h_tag("obex.merkle.empty", &[]); }
    let mut lvl: Vec<Hash256> = leaves_payload.iter().map(|p| merkle_leaf(p)).collect();
    while lvl.len() > 1 {
        if lvl.len() % 2 == 1 { lvl.push(*lvl.last().unwrap()); }
        let mut nxt = Vec::with_capacity(lvl.len()/2);
        for i in (0..lvl.len()).step_by(2) { nxt.push(merkle_node(&lvl[i], &lvl[i+1])); }
        lvl = nxt;
    }
    lvl[0]
}

// â€”â€”â€” Providers (adapters) â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
// Beacon (VDF) equality checker + caps
pub trait BeaconVerifier {
    /// Returns true iff:
    ///   seed_commit == H("obex.slot.seed",[parent_id, LE(slot,8)]) &&
    ///   backend proof verifies (reconstructs canonical Y_raw) &&
    ///   vdf_y_core == H("obex.vdf.ycore", [Y_raw]) &&
    ///   vdf_y_edge == H("obex.vdf.edge",  [vdf_y_core]) &&
    ///   |vdf_pi| â‰¤ MAX_PI_LEN, |vdf_ell| â‰¤ MAX_ELL_LEN
    fn verify(
        &self,
        parent_id: &Hash256,
        slot: u64,
        seed_commit: &Hash256,
        vdf_y_core:  &Hash256,
        vdf_y_edge:  &Hash256,
        vdf_pi:      &[u8],
        vdf_ell:     &[u8],
    ) -> bool;
}

pub trait TicketRootProvider {
    /// Deterministically compute ticket_root for slot `slot` from canonical TicketRecords (Î± III):
    ///   - sort by txid ascending (raw bytes)
    ///   - leaf payload = H("obex.ticket.leaf",[]) || fields...
    ///   - return binary Merkle root
    fn compute_ticket_root(&self, slot: u64) -> Hash256;
}
pub trait PartRootProvider {
    /// Deterministically compute part_root for slot `slot` from Î± I:
    ///   - build P_s (sorted PKs)
    ///   - leaf payload = H("obex.part.leaf",[]) || pk
    ///   - return binary Merkle root
    fn compute_part_root(&self, slot: u64) -> Hash256;
}
pub trait TxRootProvider {
    /// Deterministically compute txroot for slot `slot` over executed txids (Î± III):
    ///   - sort txids ascending
    ///   - leaf payload = H("obex.txid.leaf",[]) || txid
    ///   - return binary Merkle root
    fn compute_txroot(&self, slot: u64) -> Hash256;
}

// â€”â€”â€” Constants â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
pub const OBEX_ALPHA_II_VERSION: u32 = 2;

// â€”â€”â€” Header struct & canonical ID â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
#[derive(Clone)]
pub struct Header {
    pub parent_id:         Hash256,
    pub slot:              u64,
    pub obex_version:      u32,

    // Beacon (VDF)
    pub seed_commit:       Hash256,
    pub vdf_y_core:        Hash256,
    pub vdf_y_edge:        Hash256,
    pub vdf_pi:            Vec<u8>,  // len-prefixed on the wire
    pub vdf_ell:           Vec<u8>,  // len-prefixed on the wire

    // Deterministic commitments
    pub ticket_root:       Hash256,  // slot s
    pub part_root:         Hash256,  // slot s
    pub txroot_prev:       Hash256,  // slot s-1
}

pub fn obex_header_id(h: &Header) -> Hash256 {
    h_tag("obex.header.id", &[
        &h.parent_id,
        &le_bytes::<8>(h.slot as u128),
        &le_bytes::<4>(h.obex_version as u128),

        &h.seed_commit,
        &h.vdf_y_core,
        &h.vdf_y_edge,
        &le_bytes::<4>(h.vdf_pi.len() as u128),  &h.vdf_pi,
        &le_bytes::<4>(h.vdf_ell.len() as u128), &h.vdf_ell,

        &h.ticket_root,
        &h.part_root,
        &h.txroot_prev,
    ])
}

// â€”â€”â€” Builder & Validator â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
pub enum BuildErr { /* reserved: provider failures */ }

pub enum ValidateErr {
    BadParentLink,
    BadSlotProgression,
    BeaconInvalid,
    TicketRootMismatch,
    PartRootMismatch,
    TxRootPrevMismatch,
    VersionMismatch,
}

pub fn build_header(
    parent: &Header,
    beacon_fields: (Hash256, Hash256, Hash256, Vec<u8>, Vec<u8>), // (seed_commit, y_core, y_edge, pi, ell)
    ticket_roots: &impl TicketRootProvider,
    part_roots:   &impl PartRootProvider,
    tx_roots:     &impl TxRootProvider,
    obex_version: u32,
) -> Result<Header, BuildErr> {
    let s = parent.slot + 1;
    let (seed_commit, y_core, y_edge, pi, ell) = beacon_fields;

    let ticket_root = ticket_roots.compute_ticket_root(s);
    let part_root   = part_roots.compute_part_root(s);
    let txroot_prev = tx_roots.compute_txroot(parent.slot);

    Ok(Header {
        parent_id: obex_header_id(parent),
        slot: s,
        obex_version,
        seed_commit,
        vdf_y_core: y_core,
        vdf_y_edge: y_edge,
        vdf_pi: pi,
        vdf_ell: ell,
        ticket_root,
        part_root,
        txroot_prev,
    })
}

pub fn validate_header(
    h: &Header,
    parent: &Header,
    beacon: &impl BeaconVerifier,
    ticket_roots: &impl TicketRootProvider,
    part_roots:   &impl PartRootProvider,
    tx_roots:     &impl TxRootProvider,
    expected_version: u32,
) -> Result<(), ValidateErr> {
    // 1) Parent linkage & slot progression
    if h.parent_id != obex_header_id(parent) { return Err(ValidateErr::BadParentLink); }
    if h.slot != parent.slot + 1 { return Err(ValidateErr::BadSlotProgression); }

    // 2) Beacon equality & caps
    if !beacon.verify(
        &h.parent_id, h.slot,
        &h.seed_commit, &h.vdf_y_core, &h.vdf_y_edge,
        &h.vdf_pi, &h.vdf_ell,
    ) { return Err(ValidateErr::BeaconInvalid); }

    // 3) Admission equality (slot s)
    let ticket_root_local = ticket_roots.compute_ticket_root(h.slot);
    if h.ticket_root != ticket_root_local { return Err(ValidateErr::TicketRootMismatch); }

    // 4) Participation equality (slot s)
    let part_root_local = part_roots.compute_part_root(h.slot);
    if h.part_root != part_root_local { return Err(ValidateErr::PartRootMismatch); }

    // 5) Execution equality (slot s-1)
    let txroot_prev_local = tx_roots.compute_txroot(parent.slot);
    if h.txroot_prev != txroot_prev_local { return Err(ValidateErr::TxRootPrevMismatch); }

    // 6) Version equality
    if h.obex_version != expected_version { return Err(ValidateErr::VersionMismatch); }

    Ok(())
}


â¸»

7. Pipeline (exact order; per slot s)

Finality window (0â€“100 ms of slot s):
	1.	Beacon: compute seed_s = H("obex.slot.seed",[parent_id, LE(s,8)]); producers supply (Y_raw, vdf_pi, vdf_ell). Validators call beacon.verify(â€¦) which enforces all beacon equalities and size caps and returns vdf_y_core, vdf_y_edge.
	2.	Admission (Î± III): deterministically build ticket_root_s.
	3.	Participation (Î± I): deterministically build part_root_s.
	4.	Execution lag-1 (Î± III): deterministically build txroot_{s-1}.
	5.	Î± II: build Header_s, validate locally (validate_header) before gossip/commit. Only one header can satisfy all equalities.

Settlement window (100â€“1000 ms of slot s):
Executor processes admitted transactions for s and produces txroot_s to be committed by Header_{s+1}.

â¸»

8. Genesis & Edge Cases
	â€¢	Genesis header for slot S0:
	â€¢	parent_id = GENESIS_PARENT_ID (constant)
	â€¢	slot = S0
	â€¢	seed_commit = H("obex.slot.seed",[GENESIS_PARENT_ID, LE(S0,8)])
	â€¢	txroot_prev = TXROOT_GENESIS (constant)
	â€¢	ticket_root = H("obex.merkle.empty",[]) if no admissions
	â€¢	part_root   = H("obex.merkle.empty",[]) if no participants
	â€¢	Beacon fields produced for (seed_commit, VDF_DELAY_T).
	â€¢	Empty sets: providers MUST return H("obex.merkle.empty",[]) for empty lists.
	â€¢	Deserialization: network decoders MUST enforce exact field order and lengths as in Â§4.1 and reject any deviation or truncation.

â¸»

9. DoS Hardening & Determinism
	â€¢	Only vdf_pi and vdf_ell are variable-length; the beacon adapter MUST enforce size caps before cryptographic work.
	â€¢	All other fields are fixed-width and must be range-checked.
	â€¢	Sorting rules for ticket/txid/participation sets are strict byte-lexicographic order.
	â€¢	All 32-byte hash comparisons and parent link checks SHOULD be constant-time.

â¸»

10. Formal Forklessness Sketch

Fix (parent, s). The following are unique deterministic functions:

seed_s        = H("obex.slot.seed",[parent_id, LE(s,8)])
(vdf_y_core, vdf_y_edge, vdf_pi, vdf_ell)  = Beacon(seed_s)  // or reject by verify()
ticket_root_s = Î±III.TicketRoot(s)
part_root_s   = Î±I.PartRoot(s)
txroot_{s-1}  = Î±III.TxRoot(s-1)

Therefore the unique valid header is:

Header_s = (
  parent_id=obex_header_id(parent), slot=s, obex_version=OBEX_ALPHA_II_VERSION,
  seed_commit=seed_s, vdf_y_core, vdf_y_edge, vdf_pi, vdf_ell,
  ticket_root=ticket_root_s, part_root=part_root_s, txroot_prev=txroot_{s-1}
)

Any competitor differs in at least one field and fails a validity equality.

â¸»

11. Conformance Checklist (engineer-facing)
	â€¢	Integers are LE fixed-width; vector lengths are LE(4).
	â€¢	Tags used exactly: "obex.header.id", "obex.slot.seed", "obex.vdf.ycore", "obex.vdf.edge", "obex.txid.leaf", "obex.ticket.leaf", "obex.merkle.*".
	â€¢	serialize_header field order is exact; only vdf_pi / vdf_ell are length-prefixed.
	â€¢	obex_header_id computed over field values as in Â§4.2.
	â€¢	Parent linkage and slot = parent.slot + 1 enforced.
	â€¢	Beacon adapter enforces all equalities and size caps.
	â€¢	ticket_root_s, part_root_s, and txroot_{s-1} recomputed locally and compared.
	â€¢	obex_version == OBEX_ALPHA_II_VERSION.
	â€¢	Constant-time comparisons for 32-byte digests.

â¸»

12. Test Vectors (ship with implementations)
	1.	Nominal header
	â€¢	Given: full parent, slot = parent.slot + 1, concrete beacon backend outputs, canonical Î± I/Î± III sets.
	â€¢	Output: Header_s, serialize_header(h), obex_header_id(h) (all hex).
	2.	Parent link failure â†’ BadParentLink.
	3.	Slot progression failure â†’ BadSlotProgression.
	4.	Beacon mismatch (flip 1 byte in vdf_y_core) â†’ BeaconInvalid.
	5.	Ticket root mismatch (shuffle TicketRecords) â†’ TicketRootMismatch.
	6.	Participation root mismatch (omit a PK) â†’ PartRootMismatch.
	7.	Txroot lag-1 mismatch (modify executed set) â†’ TxRootPrevMismatch.
	8.	Version mismatch â†’ VersionMismatch.
	9.	Empty sets â†’ both roots equal H("obex.merkle.empty",[]).

â¸»

13. Public API Summary

build_header(
    parent: &Header,
    beacon_fields: (Hash256, Hash256, Hash256, Vec<u8>, Vec<u8>),
    ticket_roots: &impl TicketRootProvider,
    part_roots:   &impl PartRootProvider,
    tx_roots:     &impl TxRootProvider,
    obex_version: u32,
) -> Result<Header, BuildErr>

validate_header(
    h: &Header,
    parent: &Header,
    beacon: &impl BeaconVerifier,
    ticket_roots: &impl TicketRootProvider,
    part_roots:   &impl PartRootProvider,
    tx_roots:     &impl TxRootProvider,
    expected_version: u32,
) -> Result<(), ValidateErr>

These two functions, together with the normative hashing/encoding rules and the Î± I/Î± III providers, are sufficient for full obex.Î± II consensus integration.

â¸»

This obex.Î± II blueprint is complete and byte-precise.
It specifies exact encodings, deterministic equalities, a canonical header identity, and a strict validator path. Implementations adhering to this document will agree bit-for-bit on header validity and identity for every slot.

obex.alpha III.txt
obex.alpha III

obex.Î± III â€” Deterministic Admission (final within slot)

Production blueprint (byte-precise, Rust-ready pseudocode).
Role: Decide, in the 0â€“100 ms finality window of slot s, which transactions enter the protocol; bind each admitted transaction to (slot=s, y_{s-1}); reserve funds and fees exactly; emit canonical TicketRecords that Merklize to ticket_root_s.
Consumes: y_{s-1} = parent.vdf_y_edge (Beacon), slot = s.
Produces: Canonical TicketRecords for slot s and the Merkle commitment ticket_root_s.
Coheres with:
	â€¢	obex.Î± II: ticket_root_s is a validity equality in the header.
	â€¢	obex.Î± I: independent; both bind to the same y_{s-1}.
	â€¢	obex.Î± T: fee rule and reservation are identical; executor settles in the 100â€“1000 ms settlement window of the same slot.

Everything below is normative. Tags, field order, lengths, and comparisons MUST match exactly; independent implementations agree bit-for-bit.

â¸»

1) Canonical hashing, encodings, and Merkle (normative)

Integers: little-endian fixed width only. LE(x, W) emits exactly W bytes (no overlong encodings).
Hash type: Hash256 = [u8; 32].

Domain-tagged SHA3-256 with length framing (global discipline):

H(tag_ascii, parts[]) =
    SHA3_256( UTF8(tag_ascii) || Î£ ( LE(|p|,8) || p ) )

Binary Merkle tree (duplicate last when odd):
	â€¢	Leaf: H("obex.merkle.leaf", payload)
	â€¢	Node: H("obex.merkle.node", L || R)
	â€¢	Empty: H("obex.merkle.empty", [])

Normative tags used in obex.Î± III:

"obex.tx.access"      "obex.tx.body.v1"     "obex.tx.id"       "obex.tx.commit"
"obex.tx.sig"         "obex.ticket.id"      "obex.ticket.leaf"
"obex.merkle.leaf"    "obex.merkle.node"    "obex.merkle.empty"

Any byte change to tag strings changes consensus.

â¸»

2) Currency units and fee rule (shared with obex.Î± T)
	â€¢	Base unit: micro-obex (Î¼OBX).
1 OBX = 100_000_000 Î¼OBX.
	â€¢	Deterministic fee function (integer-exact, enforced at admission):
	â€¢	If 10 â‰¤ amount_Î¼ â‰¤ 1000 â†’ fee_Î¼ = 10.
	â€¢	If amount_Î¼ â‰¥ 1001      â†’ fee_Î¼ = ceil( amount_Î¼ / 100 ) = (amount_Î¼ + 99) / 100.

Consensus constants (Î± III):

MIN_TX_Î¼OBX        = 10
FLAT_SWITCH_Î¼OBX   = 1_000
FLAT_FEE_Î¼OBX      = 10


â¸»

3) Access list and canonical encoding

Access lists are opaque scheduling hints for the executor; Î± III treats them as bytes but encodes them canonically.

AccessList {
    read_accounts  : list<PK>   // PK = [u8;32], sorted asc, deduplicated
    write_accounts : list<PK>   // PK = [u8;32], sorted asc, deduplicated
}

Canonical bytes (normative):

encode_access(a) =
    H("obex.tx.access", [])
    || LE(|R|,4) || concat(R[0..|R|-1])
    || LE(|W|,4) || concat(W[0..|W|-1])

Where R and W are lexicographically sorted (raw 32-byte) and deduplicated.

â¸»

4) Transaction body, identifiers, and signature (normative)

TxBodyV1 {
    sender       : PK[32]
    recipient    : PK[32]
    nonce        : u64
    amount_Î¼     : u128         // Î¼OBX
    fee_Î¼        : u128         // must equal fee(amount_Î¼)
    s_bind       : u64          // must equal current slot s
    y_bind       : Hash256      // must equal y_{s-1}
    access       : AccessList
    memo         : Bytes        // LE(4) length-prefixed; mempool policy caps size
}

Canonical bytes (exact order):

canonical_tx_bytes(tx) =
    H("obex.tx.body.v1", [])
    || sender
    || recipient
    || LE(nonce,8)
    || LE(amount_Î¼,16)
    || LE(fee_Î¼,16)
    || LE(s_bind,8)
    || y_bind
    || encode_access(access)
    || LE(|memo|,4) || memo

Identifiers and signature (normative):

txid   = H("obex.tx.id",     [ canonical_tx_bytes(tx) ])
commit = H("obex.tx.commit", [ canonical_tx_bytes(tx) ])

msg_to_sign = H("obex.tx.sig", [ canonical_tx_bytes(tx) ])
VerifySig(sender_pk, msg_to_sign, sig) -> bool   // unique, non-malleable (e.g., 32-byte PK + 64-byte Ed25519)


â¸»

5) TicketRecord and per-slot admission root (normative)

When a transaction is admitted in slot s, Î± III emits:

TicketRecord {
    ticket_id   : Hash256 = H("obex.ticket.id", [ txid, LE(s,8) ])
    txid        : Hash256
    sender      : PK[32]
    nonce       : u64
    amount_Î¼    : u128
    fee_Î¼       : u128
    s_admit     : u64    // s
    s_exec      : u64    // s  (same-slot settlement)
    commit_hash : Hash256 // commit
}

Canonical Merkle leaf payload:

enc_ticket_leaf(t) =
    H("obex.ticket.leaf", [])
    || t.ticket_id
    || t.txid
    || t.sender
    || LE(t.nonce,8)
    || LE(t.amount_Î¼,16)
    || LE(t.fee_Î¼,16)
    || LE(t.s_admit,8)
    || LE(t.s_exec,8)
    || t.commit_hash

Per-slot admission root:
	â€¢	Collect all TicketRecords for slot s.
	â€¢	Sort ascending by txid (raw bytes).
	â€¢	Leaves = enc_ticket_leaf(t) for each.
	â€¢	ticket_root_s = MerkleRoot(leaves) (binary; duplicate last; empty = H("obex.merkle.empty",[])).

â¸»

6) Deterministic admission procedure (= finality at admission)

Inputs: (tx: TxBodyV1, sig: Sig), current slot s, y_{s-1}.
State: balances, nonces, reserved amounts, per-slot TicketRecord map.

All checks MUST pass in order; on success, state writes are atomic.
	1.	Signature
VerifySig(tx.sender, H("obex.tx.sig",[canonical_tx_bytes(tx)]), sig) == true.
	2.	Slot binding
tx.s_bind == s.
	3.	Beacon binding
tx.y_bind == y_{s-1}.
	4.	Nonce equality
tx.nonce == next_nonce[tx.sender].
	5.	Amount & fee rule
	â€¢	tx.amount_Î¼ â‰¥ MIN_TX_Î¼OBX.
	â€¢	tx.fee_Î¼ == fee(tx.amount_Î¼) where

if amount_Î¼ â‰¤ 1000  => 10
else                => (amount_Î¼ + 99)/100


	6.	Funds & reservation (integer-exact; overflow-safe)
	â€¢	total = amount_Î¼ + fee_Î¼ (saturating add).
	â€¢	spendable[sender] â‰¥ total.
	â€¢	Mutate atomically:

spendable[sender] -= total
reserved[sender]  += total
next_nonce[sender]++


	7.	Execution slot
s_exec = s.
	8.	Emit TicketRecord
Build as in Â§5; insert into admitted_by_slot[s] and index by txid.

Finality condition: A transaction is final for admission in slot s iff it passes steps 1â€“8 and is present in the canonical ticket_root_s. Any header for slot s that omits it is invalid under obex.Î± II equality.

â¸»

7) Canonical per-slot processing order (determinism)

To ensure identical results across honest nodes:
	1.	Build the candidate multiset C_s from all signed blobs with (tx.s_bind == s, tx.y_bind == y_{s-1}).
	2.	Form the candidate set U_s by unique txid (identical bodies are identical txids).
	3.	Sort U_s by ascending txid (raw bytes).
	4.	Iterate in that order, applying Â§6 under the evolving state; reject deterministically on any failed step.
	5.	The resulting TicketRecord list and ticket_root_s are canonical.

Network must ensure missing bodies can be fetched to recompute ticket_root_s during header validation. Consensus binds to the Merkle root, not arrival order.

â¸»

8) Rust-ready module (byte-precise pseudocode)

Replace sha3_256 and signature verification with vetted implementations. All encodings, tags, and field orders are consensus-critical.

// =========================== obex_alpha_iii.rs ============================
// obex.Î± III â€” Deterministic Admission (finality within slot)
// Byte-precise, coherent with obex.Î± II (header) and obex.Î± T (tokenomics).
// ==========================================================================

#![allow(unused)]
use alloc::vec::Vec;
use alloc::collections::{BTreeMap, BTreeSet};

// â€”â€”â€” Types â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
pub type Hash256 = [u8; 32];
pub type PK      = [u8; 32];
pub type Sig     = [u8; 64];

// â€”â€”â€” Integer encodings â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
#[inline]
pub fn le_bytes<const W: usize>(mut x: u128) -> [u8; W] {
    let mut out = [0u8; W];
    for i in 0..W { out[i] = (x & 0xFF) as u8; x >>= 8; }
    out
}

// â€”â€”â€” Hashing (domain-tagged, length-framed) â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
pub fn sha3_256(_input: &[u8]) -> Hash256 { unimplemented!() }

#[inline]
pub fn h_tag(tag: &str, parts: &[&[u8]]) -> Hash256 {
    let mut buf = Vec::new();
    buf.extend_from_slice(tag.as_bytes());
    for p in parts {
        buf.extend_from_slice(&le_bytes::<8>(p.len() as u128));
        buf.extend_from_slice(p);
    }
    sha3_256(&buf)
}

// â€”â€”â€” Signature verification (unique, non-malleable encoding) â€”â€”â€”â€”
pub fn verify_sig(_pk: &PK, _msg: &[u8], _sig: &Sig) -> bool {
    // Replace with Ed25519/Schnorr verification; reject non-canonical encodings.
    unimplemented!()
}

// â€”â€”â€” Merkle (binary; duplicate last on odd) â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
pub fn merkle_leaf(payload: &[u8]) -> Hash256 { h_tag("obex.merkle.leaf", &[payload]) }

pub fn merkle_node(l: &Hash256, r: &Hash256) -> Hash256 {
    let mut cat = [0u8; 64];
    cat[..32].copy_from_slice(l);
    cat[32..].copy_from_slice(r);
    h_tag("obex.merkle.node", &[&cat])
}

pub fn merkle_root(leaves_payload: &[Vec<u8>]) -> Hash256 {
    if leaves_payload.is_empty() { return h_tag("obex.merkle.empty", &[]); }
    let mut level: Vec<Hash256> = leaves_payload.iter().map(|p| merkle_leaf(p)).collect();
    while level.len() > 1 {
        if level.len() % 2 == 1 { level.push(*level.last().unwrap()); }
        let mut next = Vec::with_capacity(level.len()/2);
        for i in (0..level.len()).step_by(2) { next.push(merkle_node(&level[i], &level[i+1])); }
        level = next;
    }
    level[0]
}

// â€”â€”â€” Fee constants & rule (Î¼OBX) â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
pub const MIN_TX_uOBX:       u128 = 10;
pub const FLAT_SWITCH_uOBX:  u128 = 1_000;  // â‰¤1000 => flat fee
pub const FLAT_FEE_uOBX:     u128 = 10;     // flat fee
pub const PCT_DEN:           u128 = 100;    // 1%

#[inline]
pub fn fee_int_uobx(amount_u: u128) -> u128 {
    assert!(amount_u >= MIN_TX_uOBX);
    if amount_u <= FLAT_SWITCH_uOBX { FLAT_FEE_uOBX }
    else { (amount_u + (PCT_DEN - 1)) / PCT_DEN }  // ceil(1% of amount)
}

// â€”â€”â€” Access list & canonical encoding â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
#[derive(Clone, Default)]
pub struct AccessList {
    pub read_accounts:  Vec<PK>,
    pub write_accounts: Vec<PK>,
}

fn sort_dedup(mut v: Vec<PK>) -> Vec<PK> { v.sort(); v.dedup(); v }

pub fn encode_access(a: &AccessList) -> Vec<u8> {
    let mut R = sort_dedup(a.read_accounts.clone());
    let mut W = sort_dedup(a.write_accounts.clone());
    let mut out = Vec::new();
    out.extend_from_slice(&h_tag("obex.tx.access", &[]));
    out.extend_from_slice(&le_bytes::<4>(R.len() as u128));
    for pk in &R { out.extend_from_slice(pk); }
    out.extend_from_slice(&le_bytes::<4>(W.len() as u128));
    for pk in &W { out.extend_from_slice(pk); }
    out
}

// â€”â€”â€” Transaction body, canonical bytes, IDs â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
#[derive(Clone)]
pub struct TxBodyV1 {
    pub sender:      PK,
    pub recipient:   PK,
    pub nonce:       u64,
    pub amount_u:    u128, // Î¼OBX
    pub fee_u:       u128, // Î¼OBX
    pub s_bind:      u64,
    pub y_bind:      Hash256,
    pub access:      AccessList,
    pub memo:        Vec<u8>,
}

pub fn canonical_tx_bytes(tx: &TxBodyV1) -> Vec<u8> {
    let mut out = Vec::new();
    out.extend_from_slice(&h_tag("obex.tx.body.v1", &[]));
    out.extend_from_slice(&tx.sender);
    out.extend_from_slice(&tx.recipient);
    out.extend_from_slice(&le_bytes::<8>(tx.nonce as u128));
    out.extend_from_slice(&le_bytes::<16>(tx.amount_u));
    out.extend_from_slice(&le_bytes::<16>(tx.fee_u));
    out.extend_from_slice(&le_bytes::<8>(tx.s_bind as u128));
    out.extend_from_slice(&tx.y_bind);
    out.extend_from_slice(&encode_access(&tx.access));
    out.extend_from_slice(&le_bytes::<4>(tx.memo.len() as u128));
    out.extend_from_slice(&tx.memo);
    out
}

pub fn txid(tx: &TxBodyV1) -> Hash256 {
    h_tag("obex.tx.id", &[&canonical_tx_bytes(tx)])
}

pub fn tx_commit(tx: &TxBodyV1) -> Hash256 {
    h_tag("obex.tx.commit", &[&canonical_tx_bytes(tx)])
}

// â€”â€”â€” TicketRecord & canonical leaf encoding â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
#[derive(Clone)]
pub struct TicketRecord {
    pub ticket_id:   Hash256,
    pub txid:        Hash256,
    pub sender:      PK,
    pub nonce:       u64,
    pub amount_u:    u128,
    pub fee_u:       u128,
    pub s_admit:     u64,
    pub s_exec:      u64,      // == s_admit
    pub commit_hash: Hash256,
}

pub fn enc_ticket_leaf(t: &TicketRecord) -> Vec<u8> {
    let mut out = Vec::new();
    out.extend_from_slice(&h_tag("obex.ticket.leaf", &[]));
    out.extend_from_slice(&t.ticket_id);
    out.extend_from_slice(&t.txid);
    out.extend_from_slice(&t.sender);
    out.extend_from_slice(&le_bytes::<8>(t.nonce as u128));
    out.extend_from_slice(&le_bytes::<16>(t.amount_u));
    out.extend_from_slice(&le_bytes::<16>(t.fee_u));
    out.extend_from_slice(&le_bytes::<8>(t.s_admit as u128));
    out.extend_from_slice(&le_bytes::<8>(t.s_exec as u128));
    out.extend_from_slice(&t.commit_hash);
    out
}

// â€”â€”â€” Î± III state (reference in-memory model) â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
#[derive(Default)]
pub struct AlphaIIIState {
    // balances
    pub spendable_u: BTreeMap<PK, u128>, // Î¼OBX
    pub reserved_u:  BTreeMap<PK, u128>, // Î¼OBX
    pub next_nonce:  BTreeMap<PK, u64>,

    // per-slot admission artifacts
    pub admitted_by_slot: BTreeMap<u64, Vec<TicketRecord>>, // s -> TicketRecords
    pub tickets_by_txid:  BTreeMap<Hash256, TicketRecord>,  // txid -> record
}

impl AlphaIIIState {
    pub fn spendable_of(&self, pk: &PK) -> u128 { *self.spendable_u.get(pk).unwrap_or(&0) }
    pub fn reserved_of(&self,  pk: &PK) -> u128 { *self.reserved_u .get(pk).unwrap_or(&0) }
    pub fn nonce_of(&self,     pk: &PK) -> u64  { *self.next_nonce .get(pk).unwrap_or(&0) }
}

// â€”â€”â€” Admission result types â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
pub enum AdmitErr {
    BadSig,
    WrongSlot,
    WrongBeacon,
    NonceMismatch,
    BelowMinAmount,
    FeeMismatch,
    InsufficientFunds,
}

pub enum AdmitResult {
    Finalized(TicketRecord), // admission success
    Rejected(AdmitErr),
}

// â€”â€”â€” Single-transaction admission (deterministic) â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
pub fn admit_single(
    tx: &TxBodyV1,
    sig: &Sig,
    s_now: u64,
    y_prev: &Hash256,      // y_{s-1}
    st: &mut AlphaIIIState,
) -> AdmitResult {
    // 1) Signature
    let msg = h_tag("obex.tx.sig", &[&canonical_tx_bytes(tx)]);
    if !verify_sig(&tx.sender, &msg, sig) {
        return AdmitResult::Rejected(AdmitErr::BadSig);
    }

    // 2) Slot & beacon binding
    if tx.s_bind != s_now   { return AdmitResult::Rejected(AdmitErr::WrongSlot); }
    if tx.y_bind != *y_prev { return AdmitResult::Rejected(AdmitErr::WrongBeacon); }

    // 3) Nonce equality
    if tx.nonce != st.nonce_of(&tx.sender) {
        return AdmitResult::Rejected(AdmitErr::NonceMismatch);
    }

    // 4) Amount & fee rule (integer-exact)
    if tx.amount_u < MIN_TX_uOBX {
        return AdmitResult::Rejected(AdmitErr::BelowMinAmount);
    }
    if tx.fee_u != fee_int_uobx(tx.amount_u) {
        return AdmitResult::Rejected(AdmitErr::FeeMismatch);
    }

    // 5) Funds & reservation
    let total = tx.amount_u.saturating_add(tx.fee_u);
    if st.spendable_of(&tx.sender) < total {
        return AdmitResult::Rejected(AdmitErr::InsufficientFunds);
    }

    *st.spendable_u.entry(tx.sender).or_insert(0) -= total;
    *st.reserved_u .entry(tx.sender).or_insert(0) += total;
    *st.next_nonce.entry(tx.sender).or_insert(0)  += 1;

    // 6) Deterministic execution slot (same slot)
    let xid    = txid(tx);
    let s_exec = s_now;

    // 7) Emit TicketRecord
    let rec = TicketRecord {
        ticket_id:   h_tag("obex.ticket.id", &[&xid, &le_bytes::<8>(s_now as u128)]),
        txid:        xid,
        sender:      tx.sender,
        nonce:       tx.nonce,
        amount_u:    tx.amount_u,
        fee_u:       tx.fee_u,
        s_admit:     s_now,
        s_exec:      s_exec,
        commit_hash: tx_commit(tx),
    };

    st.admitted_by_slot.entry(s_now).or_default().push(rec.clone());
    st.tickets_by_txid.insert(rec.txid, rec.clone());

    AdmitResult::Finalized(rec)
}

// â€”â€”â€” Canonical batch admission for slot s â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
pub fn admit_slot_canonical(
    s_now: u64,
    y_prev: &Hash256,
    candidates_sorted: &[(TxBodyV1, Sig)], // sorted by txid ascending
    st: &mut AlphaIIIState,
) -> Vec<TicketRecord> {
    let mut out = Vec::new();
    for (tx, sig) in candidates_sorted {
        match admit_single(tx, sig, s_now, y_prev, st) {
            AdmitResult::Finalized(rec) => out.push(rec),
            AdmitResult::Rejected(_)    => { /* ignore for this slot */ }
        }
    }
    out
}

// â€”â€”â€” Build per-slot ticket_root (leaves + root) â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
pub fn build_ticket_root_for_slot(s: u64, st: &AlphaIIIState) -> (Vec<Vec<u8>>, Hash256) {
    let mut L = st.admitted_by_slot.get(&s).cloned().unwrap_or_default();
    // Canonical order: ascending txid (raw bytes)
    L.sort_by(|a, b| a.txid.cmp(&b.txid));
    let leaves: Vec<Vec<u8>> = L.iter().map(|t| enc_ticket_leaf(t)).collect();
    let root = merkle_root(&leaves);
    (leaves, root)
}


â¸»

9) Pipeline integration (per slot s)

Finality window (0â€“100 ms):
	1.	Beacon validates y_{s-1} and seeds for s (via Î± IIâ€™s adapter).
	2.	obex.Î± III:
	â€¢	Gather candidates with (s_bind == s, y_bind == y_{s-1}).
	â€¢	Deduplicate by txid, sort ascending.
	â€¢	Run admit_slot_canonical.
	â€¢	Compute (leaves_s, ticket_root_s) = build_ticket_root_for_slot(s, â€¦).
	3.	obex.Î± II: Asserts ticket_root_s equality in the header.

Settlement window (100â€“1000 ms of the same slot s):
	â€¢	Executor settles each TicketRecord with s_exec = s (ledger debits/credits), credits fee escrow, performs fee routing (Î± T), materializes system transactions, and emits txroot_s that Î± II commits in Header_{s+1}.

â¸»

10) Determinism, safety, and DoS hardening
	â€¢	Determinism: Candidate set unique by txid, strict byte-lexicographic ordering, and stepwise admission under evolving state yields the same admitted subset on every honest node.
	â€¢	Finality at admission: Inclusion in ticket_root_s is final for admission; any header omitting it is invalid by equality.
	â€¢	Replay resistance: (s_bind == s) and (y_bind == y_{s-1}) bind the transaction to the parent beacon lineage; replay across slots fails equalities.
	â€¢	Economic integrity: Reservation of amount_Î¼ + fee_Î¼ at admission prevents underfunding at settlement; fee equality enforces Î± T policy.
	â€¢	DoS limits: Mempool should cap memo size and per-slot candidate volume; consensus objects (TicketRecords and leaves) are fixed-size; Merkle work is linear; signature checks are bounded.

â¸»

11) Genesis and edge cases
	â€¢	Genesis slot S0: If no admissions, ticket_root_{S0} = H("obex.merkle.empty",[]).
	â€¢	Empty slot: same root as above.
	â€¢	Overflow checks: Use saturating arithmetic when forming totals; treat actual overflows (impractical with u128) as invalid inputs and reject admission.

â¸»

12) Conformance checklist (engineer-facing)
	â€¢	Integers are LE fixed-width; vector lengths are LE(4) exactly.
	â€¢	Tags used exactly as listed in Â§1/Â§4/Â§5.
	â€¢	encode_access sorts & dedups PKs; encodes counts with LE(4).
	â€¢	canonical_tx_bytes order exact; memo is LE(4) length-prefixed.
	â€¢	txid = H("obex.tx.id",[canonical_tx_bytes]), commit = H("obex.tx.commit",[canonical_tx_bytes]).
	â€¢	Signature verified over H("obex.tx.sig",[canonical_tx_bytes]) with unique, non-malleable encoding.
	â€¢	Admission steps 1â€“8 enforced exactly; atomic state updates on success.
	â€¢	Per-slot canonical selection: unique by txid, sorted asc, iterate under evolving state.
	â€¢	enc_ticket_leaf byte layout exact; ticket_root_s = MerkleRoot(leaves) with binary/dup-last rules; empty = H("obex.merkle.empty",[]).
	â€¢	s_exec == s_admit == s.
	â€¢	Providers used by Î± II recompute the same ticket_root_s.

â¸»

13) Test vectors (ship with implementation)

Provide hex for inputs, canonical bytes, and outputs.
	1.	Nominal admission batch â€” 2â€“3 valid transactions with increasing nonces.
	â€¢	Outputs: txids, TicketRecords, enc_ticket_leaf bytes, ticket_root_s.
	2.	Fee mismatch â€” identical tx with fee_Î¼ off by 1 â†’ FeeMismatch.
	3.	Wrong beacon â€” y_bind â‰  y_{s-1} â†’ WrongBeacon.
	4.	Nonce conflict â€” two txs from same sender with same nonce; only the lower txid admits under evolving state; the other â†’ NonceMismatch or insufficient funds depending on order.
	5.	Insufficient funds â€” sender balance < amount_Î¼ + fee_Î¼ â†’ InsufficientFunds.
	6.	Empty slot â€” no admissions â†’ ticket_root_s = H("obex.merkle.empty",[]).
	7.	Order invariance â€” shuffle candidate arrival; admitted set & ticket_root_s are identical due to canonical txid sorting.

â¸»

14) Public API summary (host-node integration)

// Admit a single transaction (deterministic, stateful)
admit_single(
    tx: &TxBodyV1,
    sig: &Sig,
    s_now: u64,
    y_prev: &Hash256,
    st: &mut AlphaIIIState,
) -> AdmitResult

// Admit a deduplicated, txid-ascending batch for slot s
admit_slot_canonical(
    s_now: u64,
    y_prev: &Hash256,
    candidates_sorted: &[(TxBodyV1, Sig)],
    st: &mut AlphaIIIState,
) -> Vec<TicketRecord>

// Build the canonical per-slot root (consumed by obex.Î± II)
build_ticket_root_for_slot(
    s: u64,
    st: &AlphaIIIState,
) -> (Vec<Vec<u8>>, Hash256)  // (leaves, ticket_root_s)


â¸»

This obex.Î± III blueprint is complete and byte-precise.
It specifies exact encodings, deterministic admission checks, canonical leaf layouts, and a verifier-cheap Merkle commitment. Implementations following this document will agree bit-for-bit on admission decisions and ticket_root_s for every slot.

obex.alpha T.txt
obex.alpha T

obex.Î± T â€” Tokenomics (Deterministic Emission, Fees, and Validator Rewards)

Production blueprint (byte-precise; Rust-ready pseudocode).
Role: Provide ledger-only, integer-exact, race-free issuance, fee routing, and validator rewards that are consensus-deterministic and bit-compatible across independent implementations.

Consumes (consensus inputs per slot s):
	â€¢	y_edge_s â€” per-slot beacon edge (from obex.Î± IIâ€™s beacon verifier).
	â€¢	P_s and part_root_s â€” participation set and commitment for slot s (from obex.Î± I; committed by obex.Î± II).
	â€¢	ticket_root_s â€” admission commitment (from obex.Î± III; committed by obex.Î± II).
	â€¢	txroot_{s-1} â€” previous slot execution commitment (from obex.Î± II).

Produces (during settlement of slot s):
	â€¢	Exact ledger debits/credits for user transfers.
	â€¢	Fee escrow credits and deterministic releases to Verifier Pool / Treasury / Burn.
	â€¢	Emission credit for DRP (Deterministic Reward Pool).
	â€¢	DRP payouts to participants in P_s (baseline + lottery).
	â€¢	Canonical system transactions serialized into txroot_s (committed by Header_{s+1} in obex.Î± II).

All tags, encodings, ordering rules, and equalities below are normative. Independent nodes must agree bit-for-bit.

â¸»

0) Determinism & Guarantees (normative)
	â€¢	Ledger-only determinism. No wall clocks, no floats, no off-chain randomness. All effects are explicit ledger writes recorded as system transactions.
	â€¢	Exact capped emission. Geometric halving over 100 protocol years ends exactly at LAST_EMISSION_SLOT, paying a total of TOTAL_SUPPLY_Î¼OBX micro-OBX.
	â€¢	Fee integrity (no drift). The integer fee debited from a sender is first credited to Fee Escrow. Fractional accounting releases only whole Î¼OBX, bounded by escrow. Unreleasable remainders stay in escrow for future release.
	â€¢	Race-free rewards. A per-slot Deterministic Reward Pool (DRP) pays a baseline to all keys in P_s and a lottery to K distinct winners selected from P_s using y_edge_s. No proposer advantage, no timing races.
	â€¢	Cross-module coherence. Uses the same hashing, Merkle, and serialization discipline as obex.Î± I/II/III.

â¸»

1) Units, Types, Hashing, and Merkle (normative)

1.1 Units & supply

pub const Î¼OBX_PER_OBX: u128 = 100_000_000;               // 1 OBX = 1e8 Î¼OBX
pub const TOTAL_SUPPLY_OBX:    u128 = 1_000_000;          // 1.0 M OBX
pub const TOTAL_SUPPLY_Î¼OBX:   u128 = TOTAL_SUPPLY_OBX * Î¼OBX_PER_OBX; // 1e14 Î¼OBX

1.2 Slot cadence (consensus constants; no wall clock in validation)

pub const SLOT_MS: u64 = 100;                              // 10 slots/sec
pub const SLOTS_PER_SEC: u64 = 1_000 / SLOT_MS;            // 10
pub const PROTOCOL_YEAR_SEC: u64 = 365 * 86_400;           // 31_536_000
pub const SLOTS_PER_YEAR: u64 = PROTOCOL_YEAR_SEC * SLOTS_PER_SEC; // 315_360_000

Operational note (non-consensus): choose GENESIS_UNIX_TIME so that
GENESIS_UNIX_TIME + LAST_EMISSION_SLOT * SLOT_MS meets your target civil instant. Consensus never reads a clock.

1.3 Hashing, encodings, and Merkle (global discipline)
	â€¢	Integers: little-endian fixed width. LE(x, W) emits exactly W bytes (no overlong encodings).
	â€¢	Hash: Hash256 = [u8; 32].
	â€¢	Domain-tagged SHA3-256 with length framing:

H(tag_ascii, parts[]) =
    SHA3_256( UTF8(tag_ascii) || Î£ ( LE(|p|,8) || p ) )


	â€¢	Binary Merkle (duplicate last when odd):
	â€¢	Leaf: H("obex.merkle.leaf", payload)
	â€¢	Node: H("obex.merkle.node", L || R)
	â€¢	Empty: H("obex.merkle.empty", [])

Normative tags used by obex.Î± T:

"obex.sys.tx"     "obex.reward.draw"   "obex.reward.rank"
"obex.merkle.leaf"  "obex.merkle.node"  "obex.merkle.empty"

(Plus all shared tags from Î± I/II/III for txid leaves when forming txroot_s.)

â¸»

2) Emission â€” 100-year halving series (integer-exact)

2.1 Schedule

pub const YEARS_PER_HALVING: u64 = 5;
pub const SLOTS_PER_HALVING: u128 = (SLOTS_PER_YEAR as u128) * (YEARS_PER_HALVING as u128); // 1_576_800_000
pub const HALVING_COUNT: u32 = 20;                                      // 100 years
pub const LAST_EMISSION_SLOT: u128 = (SLOTS_PER_YEAR as u128) * 100;    // 31_536_000_000

2.2 Rational calibration (exact; drift-free)

Let N = HALVING_COUNT, B = SLOTS_PER_HALVING. Initial rational per-slot emission:

R0 = TOTAL_SUPPLY_Î¼OBX * 2^(N-1) / ( B * (2^N âˆ’ 1) )

Per period p âˆˆ [0..N-1], denominator doubles each halving. We accumulate with a U256 numerator to emit only whole Î¼OBX, proving Î£ payouts == TOTAL_SUPPLY_Î¼OBX at LAST_EMISSION_SLOT.

â¸»

3) Fee rule (shared with obex.Î± III; integer-only)

pub const MIN_TRANSFER_Î¼: u128 = 10;
pub const FLAT_SWITCH_Î¼:  u128 = 1_000;
pub const FLAT_FEE_Î¼:     u128 = 10;

#[inline]
pub fn fee_int(amount_Î¼: u128) -> u128 {
    assert!(amount_Î¼ >= MIN_TRANSFER_Î¼);
    if amount_Î¼ <= FLAT_SWITCH_Î¼ { FLAT_FEE_Î¼ } else { (amount_Î¼ + 99) / 100 } // ceil(1%)
}

obex.Î± III enforces the equality tx.fee_Î¼ == fee_int(tx.amount_Î¼) at admission; obex.Î± T routes the exact same integer fee on-ledger.

â¸»

4) NLB splits with Fee Escrow (no drift; epoch-stable)

4.1 System accounts (ledger identities)
	â€¢	SYS_VERIFIER_POOL â€” holds DRP corpus; receives emission & verifier fee releases; pays rewards.
	â€¢	SYS_TREASURY â€” receives treasury share.
	â€¢	SYS_BURN â€” irrecoverable sink.
	â€¢	SYS_FEE_ESCROW â€” holds all integer fees prior to release.

All credits/debits occur via system transactions (see Â§7).

4.2 Epoch-stable split policy

To avoid oscillation gaming, split percentages change only at deterministic epoch boundaries.

pub const NLB_EPOCH_SLOTS: u64 = 10_000;  // ~16m40s at 10 slots/sec

#[derive(Clone)]
pub struct NlbEpochState {
    pub epoch_index: u64,          // floor(slot / NLB_EPOCH_SLOTS)
    pub start_slot:  u64,
    pub eff_supply_snapshot: u128, // TOTAL_SUPPLY_Î¼OBX âˆ’ total_burned_Î¼
    pub v_pct: u8,                 // % to Verifier Pool
    pub t_pct: u8,                 // % to Treasury
    pub b_pct: u8,                 // % to Burn
}

Burn % table (example with floor), redirecting any burn reduction to verifiers:

const TH_500K_OBX: u128 = 500_000 * Î¼OBX_PER_OBX;
const TH_400K_OBX: u128 = 400_000 * Î¼OBX_PER_OBX;
const TH_300K_OBX: u128 = 300_000 * Î¼OBX_PER_OBX;
const TH_200K_OBX: u128 = 200_000 * Î¼OBX_PER_OBX;

const BASE_TREASURY_PCT: u8 = 40;
const INITIAL_BURN_PCT:  u8 = 20;
const BASE_VERIFIER_PCT: u8 = 40;
const BURN_FLOOR_PCT:    u8 = 1;

fn burn_percent(eff_Î¼: u128) -> u8 {
    if eff_Î¼ >= TH_500K_OBX { 20 }
    else if eff_Î¼ >= TH_400K_OBX { 15 }
    else if eff_Î¼ >= TH_300K_OBX { 10 }
    else if eff_Î¼ >= TH_200K_OBX {  5 }
    else { BURN_FLOOR_PCT }
}

fn compute_splits(eff_Î¼: u128) -> (u8,u8,u8) {
    let b = burn_percent(eff_Î¼);
    let redirect = INITIAL_BURN_PCT.saturating_sub(b); // 0..19 â†’ bump verifiers
    let v = BASE_VERIFIER_PCT.saturating_add(redirect);
    let t = BASE_TREASURY_PCT;
    debug_assert!((v as u16 + t as u16 + b as u16) == 100);
    (v,t,b)
}

4.3 Fee Escrow routing (bounded by escrow; integer releases only)

Principle: The integer fee_int debited from a sender is credited to escrow first. Fractional accumulators (scaled by 10 000) track split entitlements. On each call, we release only whole Î¼OBX, capped by escrow, in a deterministic priority when underfunded (reduce Burn â†’ Treasury â†’ Verifier).

â¸»

5) DRP â€” Deterministic Reward Pool (baseline + lottery; no races)

5.1 Inputs per slot s
	â€¢	P_s â€” participation set (sorted vector of 32-byte PK) and its committed part_root_s (from obex.Î± I / obex.Î± II).
	â€¢	y_edge_s â€” beacon edge (from obex.Î± II).
	â€¢	Pool corpus for slot s: DRP_s = emission_s + verifier_fee_release_s (ledger balance observed at SYS_VERIFIER_POOL after fee releases & emission credit in settlement of s).

5.2 Distribution parameters

pub const DRP_BASELINE_PCT: u8 = 20;   // baseline share to all in P_s
pub const DRP_K_WINNERS:    usize = 16;// number of lottery winners per slot

Policy:
	â€¢	baseline = floor(DRP_s * DRP_BASELINE_PCT / 100); per_base = floor(baseline / |P_s|); residual baseline % |P_s| burns.
	â€¢	lottery = DRP_s âˆ’ baseline; choose K = min(DRP_K_WINNERS, |P_s|) unique winners uniformly over indices 0..|P_s|-1 using y_edge_s; each winner receives per_win = floor(lottery / K); residual lottery % K burns.
	â€¢	If per_base == 0 and per_win == 0, carry corpus forward (no payouts this slot).

Winner sampling (rejection sampling; uniform; collision-free):

draw_t = H("obex.reward.draw", [ y_edge_s, LE(s,8), LE(t,4) ])
idx_t  = U64LE(draw_t[0..8]) % m
re-draw on duplicates until K unique indices

Winner payout order: sort winners by rank = H("obex.reward.rank",[y_edge_s, pk]) ascending to get a canonical, tie-break-free ordering of reward system txs.

â¸»

6) System transactions (serialization; included in txroot_s)

Every ledger write caused by tokenomics during settlement of slot s is materialized as a system transaction:

SysTx {
  kind : u8     // 0=ESCROW_CREDIT, 1=VERIFIER_CREDIT, 2=TREASURY_CREDIT, 3=BURN, 4=REWARD_PAYOUT, 5=EMISSION_CREDIT
  slot : u64    // LE(8) = slot s that produces this write
  pk   : [u8;32] // present only for REWARD_PAYOUT (else 32 zero bytes)
  amt  : u128   // LE(16) Î¼OBX amount (integer)
}

Canonical bytes:

enc_sys_tx(tx) =
  H("obex.sys.tx",[])
  || LE(kind,1)
  || LE(slot,8)
  || pk[32]
  || LE(amt,16)

Deterministic order within slot s (exact):
	1.	ESCROW_CREDIT (sum of fee_int for all executed user txs).
	2.	Emission: EMISSION_CREDIT.
	3.	Escrow releases in split order: VERIFIER_CREDIT, TREASURY_CREDIT, BURN.
	4.	REWARD_PAYOUT items ordered by lottery rank ascending where rank = H("obex.reward.rank", [y_edge_s, pk]).

All system txs (plus executed user txs) are hashed as leaves via the Î± II tx-leaf scheme to form txroot_s, which is committed by Header_{s+1} in obex.Î± II.

â¸»

7) Rust-ready pseudocode (consensus-critical)

Replace the cryptographic stubs (sha3_256) with vetted implementations. All encodings, tags, and field orders are normative.

// =============================== obex_alpha_t.rs ===============================
// obex.Î± T â€” Tokenomics (deterministic emission, fees, rewards)
// Byte-precise; ledger-only; coherent with obex.Î± I/II/III.
// ==============================================================================

#![allow(unused)]
use alloc::vec::Vec;
use alloc::collections::BTreeSet;

// â€”â€”â€” Types â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
pub type Hash256 = [u8; 32];

// â€”â€”â€” Integer encodings â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
#[inline]
pub fn le_bytes<const W: usize>(mut x: u128) -> [u8; W] {
    let mut out = [0u8; W];
    for i in 0..W { out[i] = (x & 0xFF) as u8; x >>= 8; }
    out
}

#[inline]
pub fn u64_from_le(b: &[u8]) -> u64 {
    let mut x = 0u64;
    for (i,&bi) in b.iter().take(8).enumerate() { x |= (bi as u64) << (8*i); }
    x
}

// â€”â€”â€” Hashing (domain-tagged, length-framed) â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
pub fn sha3_256(_input: &[u8]) -> Hash256 { unimplemented!() }

#[inline]
pub fn h_tag(tag: &str, parts: &[&[u8]]) -> Hash256 {
    let mut buf = Vec::new();
    buf.extend_from_slice(tag.as_bytes());
    for p in parts {
        buf.extend_from_slice(&le_bytes::<8>(p.len() as u128));
        buf.extend_from_slice(p);
    }
    sha3_256(&buf)
}

// â€”â€”â€” Merkle helpers (for completeness) â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
#[inline] pub fn merkle_leaf(payload: &[u8]) -> Hash256 { h_tag("obex.merkle.leaf", &[payload]) }

#[inline]
pub fn merkle_node(l: &Hash256, r: &Hash256) -> Hash256 {
    let mut cat = [0u8; 64];
    cat[..32].copy_from_slice(l);
    cat[32..].copy_from_slice(r);
    h_tag("obex.merkle.node", &[&cat])
}

pub fn merkle_root(leaves_payload: &[Vec<u8>]) -> Hash256 {
    if leaves_payload.is_empty() { return h_tag("obex.merkle.empty", &[]); }
    let mut lvl: Vec<Hash256> = leaves_payload.iter().map(|p| merkle_leaf(p)).collect();
    while lvl.len() > 1 {
        if lvl.len() % 2 == 1 { lvl.push(*lvl.last().unwrap()); }
        let mut nxt = Vec::with_capacity(lvl.len()/2);
        for i in (0..lvl.len()).step_by(2) { nxt.push(merkle_node(&lvl[i], &lvl[i+1])); }
        lvl = nxt;
    }
    lvl[0]
}

// â€”â€”â€” Supply & timing constants â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
pub const Î¼OBX_PER_OBX: u128 = 100_000_000;
pub const TOTAL_SUPPLY_OBX:  u128 = 1_000_000;
pub const TOTAL_SUPPLY_Î¼OBX: u128 = TOTAL_SUPPLY_OBX * Î¼OBX_PER_OBX;

pub const SLOT_MS: u64 = 100;
pub const SLOTS_PER_SEC: u64 = 1_000 / SLOT_MS;
pub const PROTOCOL_YEAR_SEC: u64 = 365 * 86_400;
pub const SLOTS_PER_YEAR: u64 = PROTOCOL_YEAR_SEC * SLOTS_PER_SEC;

// Halving
pub const YEARS_PER_HALVING: u64 = 5;
pub const SLOTS_PER_HALVING: u128 = (SLOTS_PER_YEAR as u128) * (YEARS_PER_HALVING as u128);
pub const HALVING_COUNT: u32 = 20;
pub const LAST_EMISSION_SLOT: u128 = (SLOTS_PER_YEAR as u128) * 100;

// â€”â€”â€” Emission accumulator (exact rational; U256) â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
use primitive_types::U256;
#[inline] fn pow2_u256(n: u32) -> U256 { U256::from(1u8) << n }

lazy_static::lazy_static! {
    static ref TWO_POW_N_MINUS1: U256 = pow2_u256(HALVING_COUNT - 1);
    static ref TWO_POW_N:        U256 = pow2_u256(HALVING_COUNT);
    static ref R0_NUM: U256 = U256::from(TOTAL_SUPPLY_Î¼OBX) * *TWO_POW_N_MINUS1;
    static ref R0_DEN: U256 = U256::from(SLOTS_PER_HALVING) * (*TWO_POW_N - U256::from(1u8));
}

#[derive(Clone, Default)]
pub struct EmissionState {
    pub total_emitted_Î¼: u128, // <= TOTAL_SUPPLY_Î¼OBX
    pub acc_num: U256,         // rational numerator accumulator
}

#[inline]
fn period_index(slot_1based: u128) -> u32 {
    let h = slot_1based - 1;
    (h / SLOTS_PER_HALVING) as u32
}

#[inline]
fn reward_den_for_period(p: u32) -> U256 { *R0_DEN * pow2_u256(p) }

/// Deterministic emission for slot s=1..LAST_EMISSION_SLOT.
/// Credits the DRP via `credit_emission` (e.g., credit SYS_VERIFIER_POOL).
pub fn on_slot_emission(
    st: &mut EmissionState,
    slot_1based: u128,
    mut credit_emission: impl FnMut(u128), // produces EMISSION_CREDIT sys tx
) {
    if slot_1based == 0 || slot_1based > LAST_EMISSION_SLOT { return; }

    let p = period_index(slot_1based);
    let den = reward_den_for_period(p);

    st.acc_num = st.acc_num + *R0_NUM;

    let payout_u256 = st.acc_num / den;
    if payout_u256 > U256::zero() {
        assert!(payout_u256 <= U256::from(u128::MAX));
        let payout = payout_u256.as_u128();

        let remaining = TOTAL_SUPPLY_Î¼OBX - st.total_emitted_Î¼;
        let pay = payout.min(remaining);
        if pay > 0 {
            credit_emission(pay);
            st.total_emitted_Î¼ = st.total_emitted_Î¼.saturating_add(pay);
            st.acc_num = st.acc_num - (U256::from(pay) * den);
        }
    }

    if slot_1based == LAST_EMISSION_SLOT {
        assert!(st.total_emitted_Î¼ == TOTAL_SUPPLY_Î¼OBX);
    }
}

// â€”â€”â€” Fee rule (shared with Î± III) â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
pub const MIN_TRANSFER_Î¼: u128 = 10;
pub const FLAT_SWITCH_Î¼:  u128 = 1_000;
pub const FLAT_FEE_Î¼:     u128 = 10;

#[inline]
pub fn fee_int(amount_Î¼: u128) -> u128 {
    assert!(amount_Î¼ >= MIN_TRANSFER_Î¼);
    if amount_Î¼ <= FLAT_SWITCH_Î¼ { FLAT_FEE_Î¼ } else { (amount_Î¼ + 99) / 100 }
}

// â€”â€”â€” NLB epoch & fee escrow state â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
pub const NLB_EPOCH_SLOTS: u64 = 10_000;

#[derive(Clone)]
pub struct NlbEpochState {
    pub epoch_index: u64,
    pub start_slot:  u64,
    pub eff_supply_snapshot_Î¼: u128,
    pub v_pct: u8,
    pub t_pct: u8,
    pub b_pct: u8,
}

#[derive(Clone, Default)]
pub struct FeeSplitState {
    // fractional numerators (denominator 10_000), scaled from fee basis (100 or 1)
    pub acc_v_num: u128,
    pub acc_t_num: u128,
    pub acc_b_num: u128,

    // escrow & burned totals
    pub fee_escrow_Î¼: u128,
    pub total_burned_Î¼: u128,

    pub nlb: NlbEpochState,
}

const TH_500K_OBX: u128 = 500_000 * Î¼OBX_PER_OBX;
const TH_400K_OBX: u128 = 400_000 * Î¼OBX_PER_OBX;
const TH_300K_OBX: u128 = 300_000 * Î¼OBX_PER_OBX;
const TH_200K_OBX: u128 = 200_000 * Î¼OBX_PER_OBX;

const BASE_TREASURY_PCT: u8 = 40;
const INITIAL_BURN_PCT:  u8 = 20;
const BASE_VERIFIER_PCT: u8 = 40;
const BURN_FLOOR_PCT:    u8 = 1;

#[inline]
fn burn_percent(eff_Î¼: u128) -> u8 {
    if eff_Î¼ >= TH_500K_OBX { 20 }
    else if eff_Î¼ >= TH_400K_OBX { 15 }
    else if eff_Î¼ >= TH_300K_OBX { 10 }
    else if eff_Î¼ >= TH_200K_OBX {  5 }
    else { BURN_FLOOR_PCT }
}

#[inline]
fn compute_splits(eff_Î¼: u128) -> (u8,u8,u8) {
    let b = burn_percent(eff_Î¼);
    let redirect = INITIAL_BURN_PCT.saturating_sub(b);
    let v = BASE_VERIFIER_PCT.saturating_add(redirect);
    let t = BASE_TREASURY_PCT;
    debug_assert!((v as u16 + t as u16 + b as u16) == 100);
    (v,t,b)
}

#[inline]
fn epoch_index(slot: u64) -> u64 { slot / NLB_EPOCH_SLOTS }

pub fn nlb_roll_epoch_if_needed(slot: u64, fs: &mut FeeSplitState) {
    let idx = epoch_index(slot);
    if idx == fs.nlb.epoch_index { return; }
    fs.nlb.epoch_index = idx;
    fs.nlb.start_slot  = idx * NLB_EPOCH_SLOTS;
    let eff_Î¼ = TOTAL_SUPPLY_Î¼OBX.saturating_sub(fs.total_burned_Î¼);
    fs.nlb.eff_supply_snapshot_Î¼ = eff_Î¼;
    let (v,t,b) = compute_splits(eff_Î¼);
    fs.nlb.v_pct = v; fs.nlb.t_pct = t; fs.nlb.b_pct = b;
}

// â€”â€”â€” Fee routing via escrow (bounded releases; deterministic) â€”â€”â€”â€”â€”
pub fn route_fee_with_nlb(
    fs: &mut FeeSplitState,
    fee_num: u128, fee_den: u128,         // fee as rational: (10/1) or (amount/100)
    mut credit_verifier: impl FnMut(u128),// debits escrow â†’ credit Verifier Pool (sys tx)
    mut credit_treasury: impl FnMut(u128),// debits escrow â†’ credit Treasury     (sys tx)
    mut burn:            impl FnMut(u128),// debits escrow â†’ burn                (sys tx)
) {
    // Lift to denominator 100
    let fee_num_over_100 = if fee_den == 1 { fee_num.saturating_mul(100) } else { fee_num };

    // Scale to denominator 10_000 with epoch %s
    let add_v = fee_num_over_100.saturating_mul(fs.nlb.v_pct as u128);
    let add_t = fee_num_over_100.saturating_mul(fs.nlb.t_pct as u128);
    let add_b = fee_num_over_100.saturating_mul(fs.nlb.b_pct as u128);
    fs.acc_v_num = fs.acc_v_num.saturating_add(add_v);
    fs.acc_t_num = fs.acc_t_num.saturating_add(add_t);
    fs.acc_b_num = fs.acc_b_num.saturating_add(add_b);

    const DEN_10K: u128 = 10_000;
    let mut rel_v = fs.acc_v_num / DEN_10K;
    let mut rel_t = fs.acc_t_num / DEN_10K;
    let mut rel_b = fs.acc_b_num / DEN_10K;

    // Cap by escrow
    let total_rel = rel_v.saturating_add(rel_t).saturating_add(rel_b);
    if total_rel > fs.fee_escrow_Î¼ {
        // Deterministic deficit resolution: reduce Burn â†’ Treasury â†’ Verifier
        let mut deficit = total_rel - fs.fee_escrow_Î¼;
        let mut reduce = |x: &mut u128, d: &mut u128| { let cut = (*x).min(*d); *x -= cut; *d -= cut; };
        reduce(&mut rel_b, &mut deficit);
        reduce(&mut rel_t, &mut deficit);
        reduce(&mut rel_v, &mut deficit);
    }

    if rel_v > 0 { credit_verifier(rel_v); fs.fee_escrow_Î¼ -= rel_v; fs.acc_v_num %= DEN_10K; }
    if rel_t > 0 { credit_treasury(rel_t); fs.fee_escrow_Î¼ -= rel_t; fs.acc_t_num %= DEN_10K; }
    if rel_b > 0 { burn(rel_b);            fs.fee_escrow_Î¼ -= rel_b; fs.acc_b_num %= DEN_10K; fs.total_burned_Î¼ = fs.total_burned_Î¼.saturating_add(rel_b); }
}

// â€”â€”â€” Transfer processing (executor path; integer-only) â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
pub fn process_transfer(
    slot: u64,
    sender_balance_Î¼: u128,
    amount_Î¼: u128,
    fs: &mut FeeSplitState,

    // ledger hooks (each emits a system transaction)
    mut debit_sender:    impl FnMut(u128), // total_debit
    mut credit_recipient:impl FnMut(u128), // amount_Î¼
    mut escrow_credit:   impl FnMut(u128), // ESCROW_CREDIT
    mut credit_verifier: impl FnMut(u128), // VERIFIER_CREDIT
    mut credit_treasury: impl FnMut(u128), // TREASURY_CREDIT
    mut burn:            impl FnMut(u128), // BURN
) -> (u128 /*total_debit*/, u128 /*fee_int*/) {
    assert!(amount_Î¼ >= MIN_TRANSFER_Î¼);

    // Lock epoch parameters for this slot
    nlb_roll_epoch_if_needed(slot, fs);

    // Fee as rational (num/den)
    let (fee_num, fee_den) = if amount_Î¼ <= FLAT_SWITCH_Î¼ { (FLAT_FEE_Î¼, 1) } else { (amount_Î¼, 100) };
    let fee_Î¼ = (fee_num + (fee_den - 1)) / fee_den; // integer ceil

    let total_debit = amount_Î¼.saturating_add(fee_Î¼);
    assert!(sender_balance_Î¼ >= total_debit);

    // Ledger effects: debit sender; credit recipient
    debit_sender(total_debit);
    credit_recipient(amount_Î¼);

    // Fee escrow credit
    fs.fee_escrow_Î¼ = fs.fee_escrow_Î¼.saturating_add(fee_Î¼);
    escrow_credit(fee_Î¼);

    // Attempt releases (bounded by escrow)
    route_fee_with_nlb(fs, fee_num, fee_den, credit_verifier, credit_treasury, burn);

    (total_debit, fee_Î¼)
}

// â€”â€”â€” DRP: winner sampling & distribution â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
#[inline]
fn ctr_draw(y: &Hash256, s: u64, t: u32) -> Hash256 {
    h_tag("obex.reward.draw", &[y, &le_bytes::<8>(s as u128), &le_bytes::<4>(t as u128)])
}

pub fn pick_k_unique_indices(y_edge_s: &Hash256, s: u64, m: usize, k: usize) -> Vec<usize> {
    if m == 0 || k == 0 { return vec![]; }
    let mut out = Vec::with_capacity(k);
    let mut seen = BTreeSet::new();
    let mut t: u32 = 0;
    while out.len() < k {
        let h = ctr_draw(y_edge_s, s, t);
        let idx = (u64_from_le(&h[..8]) % (m as u64)) as usize;
        if seen.insert(idx) { out.push(idx); }
        t = t.wrapping_add(1);
    }
    out
}

#[inline] fn reward_rank(y: &Hash256, pk: &Hash256) -> Hash256 {
    h_tag("obex.reward.rank", &[y, pk])
}

pub const DRP_BASELINE_PCT: u8 = 20;
pub const DRP_K_WINNERS:    usize = 16;

pub fn distribute_drp_for_slot(
    s: u64,
    y_edge_s: &Hash256,
    part_set_sorted: &[Hash256],       // P_s; pk as 32-byte arrays; sorted ascending
    mut read_pool_balance: impl FnMut() -> u128,
    mut debit_pool:        impl FnMut(u128),            // total payout
    mut credit_pk:         impl FnMut(&Hash256, u128),  // REWARD_PAYOUT sys tx
    mut burn_fn:           impl FnMut(u128),            // BURN sys tx
) {
    let m = part_set_sorted.len();
    let drp = read_pool_balance();
    if drp == 0 || m == 0 { return; }

    let baseline = (drp as u128 * (DRP_BASELINE_PCT as u128)) / 100;
    let lottery  = drp - baseline;

    let per_base = baseline / (m as u128);
    let base_rem = baseline % (m as u128);

    let k = core::cmp::min(DRP_K_WINNERS, m);
    if k == 0 { return; }

    let winners_idx = pick_k_unique_indices(y_edge_s, s, m, k);
    let per_win = lottery / (k as u128);
    let lot_rem = lottery % (k as u128);

    if per_base == 0 && per_win == 0 {
        // carry forward corpus; no payouts this slot
        return;
    }

    let total_pay = per_base * (m as u128) + per_win * (k as u128);
    debit_pool(total_pay);

    // Baseline: pay all participants in sorted order
    if per_base > 0 {
        for pk in part_set_sorted {
            credit_pk(pk, per_base);
        }
    }
    if base_rem > 0 { burn_fn(base_rem); }

    // Lottery: determinize payout sequence by rank
    if per_win > 0 {
        let mut winners: Vec<(usize,Hash256)> =
            winners_idx.iter().map(|&i| (i, reward_rank(y_edge_s, &part_set_sorted[i]))).collect();
        winners.sort_by(|a,b| a.1.cmp(&b.1));
        for (idx, _rank) in winners {
            credit_pk(&part_set_sorted[idx], per_win);
        }
    }
    if lot_rem > 0 { burn_fn(lot_rem); }
}


â¸»

8) Settlement pipeline within slot s (exact order)
	1.	Execute user transfers admitted by obex.Î± III with s_exec = s (debit sender, credit recipient).
	2.	Fee escrow: create one ESCROW_CREDIT system transaction for the sum of integer fees; update fee_escrow.
	3.	Escrow releases: in order VERIFIER_CREDIT, TREASURY_CREDIT, BURN, emit system transactions for any whole Î¼OBX released (bounded by escrow).
	4.	Emission: call on_slot_emission and emit a single EMISSION_CREDIT system transaction crediting the DRP (Verifier Pool).
	5.	DRP distribution: call distribute_drp_for_slot with P_s and y_edge_s; emit REWARD_PAYOUT system transactions and a BURN for any residuals.
	6.	Build txroot_s: include user txs and all system txs in canonical order (see Â§6) and commit via obex.Î± II in Header_{s+1}.

â¸»

9) Ledger state (consensus-visible) & invariants

State:
	â€¢	EmissionState (Â§2)
	â€¢	FeeSplitState (Â§4) â€” includes escrow, burned total, fractional accumulators, epoch snapshot
	â€¢	SYS_* balances â€” ordinary account balances for Verifier Pool, Treasury, Burn, and Escrow
	â€¢	DRP corpus is simply balance(SYS_VERIFIER_POOL) at settlement time

Invariants (asserted by executor):
	â€¢	At LAST_EMISSION_SLOT: total_emitted_Î¼ == TOTAL_SUPPLY_Î¼OBX.
	â€¢	Fee conservation for any slot:

Î”Escrow = +Î£ fee_int(user txs settled in s) âˆ’ (release_verifier + release_treasury + release_burn)


	â€¢	Sum of all system debits equals sum of system credits plus burns (including residual burns from DRP rounding).

â¸»

10) Conformance checklist (engineer-facing)
	â€¢	Integers are LE fixed-width; vector lengths (if any) use LE(4); no alternate encodings.
	â€¢	Tags used exactly: "obex.sys.tx", "obex.reward.draw", "obex.reward.rank", and "obex.merkle.*".
	â€¢	Emission uses the U256 rational accumulator; denominator doubles each halving; terminal equality holds.
	â€¢	Fee rule matches obex.Î± III; integer fees first credit escrow.
	â€¢	NLB splits roll only at NLB_EPOCH_SLOTS boundaries; releases are bounded by escrow with deterministic priority (Burn â†’ Treasury â†’ Verifier).
	â€¢	DRP: uses committed P_s and y_edge_s; baseline & lottery are integer; residuals burn; winner selection via rejection sampling and deterministic payout order.
	â€¢	All tokenomics-originated writes are emitted as system transactions in the canonical order in Â§6 and included in txroot_s.
	â€¢	No floats or clocks anywhere in consensus code.

â¸»

11) Test vectors (ship with implementation)

Provide hex for inputs and outputs (including all sys-tx payloads and cumulative balances).
	1.	Nominal slot: a batch of user transfers with mixed amounts (below/above flat switch), showing escrow credit, releases, emission credit, DRP payouts, residual burns, and final pool/escrow balances.
	2.	Underfunded escrow: construct fees such that fractional accumulators imply a larger release than escrow holds; verify deterministic reduction order.
	3.	Boundary halving: last slot of a halving period â†’ next slot; show R0_DEN doubling and continuity of payouts.
	4.	DRP zero per-share: tiny DRP corpus with per_base==0 and per_win==0 â†’ carry forward; next slot larger corpus pays correctly.
	5.	Terminal supply: final emission slot asserts total_emitted_Î¼ == TOTAL_SUPPLY_Î¼OBX.
	6.	Winner uniformity: fix P_s, sweep the PRNG counter; demonstrate exactly K unique winners with no modulo bias other than % m.

â¸»

12) Public API summary (host-node integration)

// Emission (once per slot in settlement)
on_slot_emission(
    st: &mut EmissionState,
    slot_1based: u128,
    credit_emission: impl FnMut(u128),        // emits EMISSION_CREDIT sys tx
)

// Transfer processing (per executed user tx)
process_transfer(
    slot: u64,
    sender_balance_Î¼: u128,
    amount_Î¼: u128,
    fs: &mut FeeSplitState,
    debit_sender:    impl FnMut(u128),        // user debit
    credit_recipient:impl FnMut(u128),        // user credit
    escrow_credit:   impl FnMut(u128),        // ESCROW_CREDIT sys tx
    credit_verifier: impl FnMut(u128),        // VERIFIER_CREDIT sys tx
    credit_treasury: impl FnMut(u128),        // TREASURY_CREDIT sys tx
    burn:            impl FnMut(u128),        // BURN sys tx
) -> (u128 /*total_debit*/, u128 /*fee_int*/)

// DRP distribution (once per slot after emission & releases)
distribute_drp_for_slot(
    s: u64,
    y_edge_s: &Hash256,
    part_set_sorted: &[Hash256],              // P_s
    read_pool_balance: impl FnMut() -> u128,  // SYS_VERIFIER_POOL balance
    debit_pool:        impl FnMut(u128),      // DRP total payout
    credit_pk:         impl FnMut(&Hash256,u128), // REWARD_PAYOUT sys tx
    burn:              impl FnMut(u128),      // BURN sys tx
)


â¸»

This obex.Î± T blueprint is complete, byte-precise, and fully coherent with obex.Î± I/II/III.
It specifies exact encodings, integer-exact emissions, escrow-based fee routing, epoch-stable splits, and deterministic per-slot rewards keyed by committed participation and the beacon edge. Implementations that follow this document will agree bit-for-bit on token flows, rewards, and txroot_s contents for every slot.

README.md
Obex Î± â€” Deterministic, Byteâ€‘Precise Engines (I, II, III, T)

## Overview

Obex Î± is a Rust workspace implementing the consensusâ€‘critical components of the OBEX protocol as four engines, plus shared primitives:

- obex_primitives: cryptographic primitives (SHA3â€‘256 domainâ€‘tagged hashing, fixedâ€‘width LE encodings, binary Merkle, constantâ€‘time digest equality) and shared constants
- obex_alpha_i: Participation Engine (VRFâ€‘salted, RAMâ€‘hard labeling, canonical participation record codecs)
- obex_alpha_ii: Deterministic Header Engine (forkless via equality checks and canonical header codecs)
- obex_alpha_iii: Deterministic Admission (fee rule, ticket records, perâ€‘slot ticket Merkle)
- obex_alpha_t: Tokenomics (emission schedule, escrow with epochâ€‘stable NLB splits, DRP distribution, system transactions)

The codebase is byteâ€‘precise and strongly typed. All crates forbid unsafe code and deny all Clippy lints including pedantic, nursery, and cargo. Consensus hashing is SHA3â€‘256 only with OBEX domain tags and length framing.

## Linting, Toolchain, and MSRV

- Toolchain: stable (pinned via `rust-toolchain.toml`)
- Lints: `#![forbid(unsafe_code)]` and `#![deny(warnings, clippy::all, clippy::pedantic, clippy::nursery, clippy::cargo)]` across crates
- Formatting: standard rustfmt
- Minimum Supported Rust Version: stable toolchain specified above

## Workspace Layout

```text
crates/
  obex_primitives/
  obex_alpha_i/      # Î± I â€” Participation
  obex_alpha_ii/     # Î± II â€” Headers
  obex_alpha_iii/    # Î± III â€” Admission
  obex_alpha_t/      # Î± T â€” Tokenomics
```

## obex_primitives

Core utilities and consensus constants. `no_std` ready with featureâ€‘gated `alloc`.

- Features:
  - default: `std`
  - optional: `alloc` (with `no_std`)
- Types:
  - `Hash256 = [u8; 32]`, `Pk32 = [u8; 32]`, `Sig64 = [u8; 64]`
- Hashing and encodings:
  - `h_tag(tag, parts) -> Hash256`: domainâ€‘tagged SHA3â€‘256 with length framing
  - `le_bytes<const W: usize>(x: u128) -> [u8; W]`: fixedâ€‘width littleâ€‘endian
  - `u64_from_le(b: &[u8]) -> u64`
- Merkle:
  - `merkle_leaf(payload)`, `merkle_node(l, r)`, `merkle_root(leaves)` (duplicateâ€‘last rule for odd counts)
  - `MerklePath { siblings, index }`, `merkle_verify_leaf(root, leaf_payload, path)`
- Constantâ€‘time digest equality:
  - `ct_eq_hash(a, b) -> bool` (via `subtle::ConstantTimeEq`)
- Consensus constants: `obex_primitives::constants`
  - Genesis: `GENESIS_PARENT_ID`, `TXROOT_GENESIS`, `GENESIS_SLOT`
  - Tags (selection; see source for complete set):
    - Merkle: `obex.merkle.leaf`, `obex.merkle.node`, `obex.merkle.empty`
    - Participation/VRF: `obex.alpha`, `obex.seed`, `obex.lbl`, `obex.idx`, `obex.chal`, `obex.part.leaf`, `obex.partrec`, `obex.vrfy`
    - Headers/Beacon: `obex.header.id`, `obex.slot.seed`, `obex.vdf.ycore`, `obex.vdf.edge`
- Transactions: `obex.tx.access`, `obex.tx.body.v1`, `obex.tx.id`, `obex.tx.commit`, `obex.tx.sig`, `obex.txid.leaf`
    - Tickets/Rewards: `obex.ticket.id`, `obex.ticket.leaf`, `obex.reward.draw`, `obex.reward.rank`

## obex_alpha_i â€” Participation Engine (Î± I)

Implements the RAMâ€‘hard labeling process and verification of canonical participation records (`ObexPartRec`).

- Key constants: `CHALLENGES_Q = 96`, `LABEL_BYTES = 32`, `MAX_PARTREC_SIZE = 600_000`
- Canonical hashing:
  - `alpha = H("obex.alpha", [ parent_id, LE(slot,8), y_edge_{s-1}, vrf_pk ])`
  - `seed  = H("obex.seed",  [ y_edge_{s-1}, pk_ed25519, vrf_y ])`
- Verification entry points:
  - `obex_verify_partrec(rec, slot, parent_id, vrf_provider) -> bool`
  - `obex_verify_partrec_bytes(bytes, slot, parent_id, vrf_provider) -> bool` (enforces `MAX_PARTREC_SIZE` preâ€‘decode)
- Canonical codecs:
  - `encode_partrec(&ObexPartRec) -> Vec<u8>`
  - `decode_partrec(&[u8]) -> Result<ObexPartRec, CodecError>` (enforces VRF lengths and challenge count)
- Participation set commitment:
  - `build_participation_set(slot, parent_id, submissions, vrf_provider) -> (Vec<Pk32>, Hash256)`; leaves are `H("obex.part.leaf",[]) || pk`, and keys are sorted for determinism
- VRF integration (RFC 9381 ECVRF):
  - Feature flags: `obex_alpha_i/ecvrf_rfc9381-ed25519` (legacy), alias `obex_alpha_i/ecvrf_rfc9381`
  - Consensus suite/lengths: `ECVRF-EDWARDS25519-SHA512-TAI`, `vrf_pk=32`, `vrf_pi=80`, `vrf_y=64`
  - Adapter: `obex_alpha_i::vrf` (vrf-rfc9381 0.0.3, TAI); Î²/Ï€ lengths enforced
  - Official RFC 9381 TAI vectors included: `crates/obex_alpha_i/tests/vrf_rfc9381_tai.rs`

## obex_alpha_ii â€” Deterministic Header Engine (Î± II)

Defines the canonical `Header`, its identity hash, codecs, and deterministic validation via equalities.

- Providers (traits): `BeaconVerifier`, `TicketRootProvider`, `PartRootProvider`, `TxRootProvider`
- Size caps (DoS protection): `MAX_PI_LEN`, `MAX_ELL_LEN`
- Canonical ID: `obex_header_id(&Header) -> Hash256` (hash over field values with explicit length framing for variableâ€‘length fields)
- Codecs: `serialize_header(&Header) -> Vec<u8>`, `deserialize_header(&[u8]) -> Result<Header, _>`
- Validation: `validate_header(h, parent, beacon, ticket_roots, part_roots, tx_roots, expected_version) -> Result<(), ValidateErr>`
  - Header ID field order (frozen): `parent_id, slot, obex_version, seed_commit, vdf_y_core, vdf_y_edge, len(vdf_pi), vdf_pi, len(vdf_ell), vdf_ell, ticket_root, part_root, txroot_prev`
  - Version: `OBEX_ALPHA_II_VERSION = 2`; `Header` includes `part_root` and validation enforces `part_root == compute_part_root(slot)`

## obex_alpha_iii â€” Deterministic Admission (Î± III)

Implements the fee rule, canonical transaction bytes, signatures, ticket records, and perâ€‘slot ticket root.

- Fee rule (integerâ€‘exact): flat for small transfers, percent for larger; `fee_int_uobx`
- Canonical transaction bytes: `canonical_tx_bytes(&TxBodyV1)`; `txid`, `tx_commit`
- Ticket records: `TicketRecord`, `enc_ticket_leaf`; perâ€‘slot root via `build_ticket_root_for_slot`
- Admission: `admit_single`, `admit_slot_canonical`
  - Determinism: sorts inputs canonically; empty set yields `obex.merkle.empty`

## obex_alpha_t â€” Tokenomics (Î± T)

Implements the emission schedule (U256 accumulator), escrow with epochâ€‘stable NLB splits, Deterministic Reward Pool (DRP) distribution, and a canonical system transaction codec.

- Emission: `on_slot_emission(st, slot_1based, credit_emission)`; halving schedule with `U256` accumulators
- NLB fee routing: `route_fee_with_nlb` with epoch state managed by `nlb_roll_epoch_if_needed`
- DRP distribution: `distribute_drp_for_slot`
  - System transactions: `enc_sys_tx`, `dec_sys_tx`; kinds include Escrow/Treasury/Verifier credits, Burn, RewardPayout, EmissionCredit; REWARD_PAYOUT items ordered by lottery rank (deterministic)

## Golden Fixtures and E2E Harness

- Golden artifacts are checked in under `tests/golden/` with deterministic generators:
  - Î± I PartRec bytes: generator `crates/obex_alpha_i/examples/gen_golden_partrec.rs`
    - Writes `crates/obex_alpha_i/tests/golden/partrec_v1.bin`
    - Tests: `crates/obex_alpha_i/tests/golden_partrec.rs` (accept + flipâ€‘bit behavior)
  - Î± II Header bytes: generator `crates/obex_alpha_ii/examples/gen_golden_header.rs`
    - Writes `crates/obex_alpha_ii/tests/golden/header_v2_parent.bin`, `header_v2_slot1.bin`, `header_v2_slot1.id.hex`
    - Tests: `crates/obex_alpha_ii/tests/golden_header_bytes.rs` (roundtrip, ID hex match, flipâ€‘bit changes)
- E2E harness: `crates/obex_alpha_ii/tests/e2e_three_slots.rs`
  - Builds a 3â€‘slot chain (slots 1..3), validates equalities, and asserts header ID uniqueness
  - Additional Î± II e2e: `crates/obex_alpha_ii/tests/e2e.rs` validates `part_root` binding

To regenerate fixtures deterministically:

```bash
cargo run --release -p obex_alpha_i  --example gen_golden_partrec
cargo run --release -p obex_alpha_ii --example gen_golden_header
```

## Security and Correctness Properties

- Byteâ€‘precise canonical codecs for consensus objects (I: `ObexPartRec`; II: `Header`; T: `SysTx`)
- Domainâ€‘separated hashing everywhere (tags centralized in `obex_primitives::constants`)
- Constantâ€‘time equality for all digest comparisons (32â€‘byte hashes)
- Deterministic sorting and duplicateâ€‘last rule in Merkle computations
 - Hashing discipline: SHA3â€‘256 only for consensus; domainâ€‘tag strings are frozen with KATs in `crates/obex_primitives/tests/kats.rs`

## Building, Testing, and Linting

```bash
# Build all crates (release)
cargo build --release --all-targets

# Run tests (dev or release)
cargo test --all-targets
cargo test --release --all-targets

# Optional: run with ECVRF adapter feature (TAI suite)
cargo test --features obex_alpha_i/ecvrf_rfc9381-ed25519 --release
cargo test --features obex_alpha_i/ecvrf_rfc9381 --release

# Clippy â€” strictest settings (pedantic, nursery, cargo) and deny warnings
cargo clippy --workspace --all-targets --all-features -- \
  -D warnings -W clippy::all -W clippy::pedantic -W clippy::nursery -W clippy::cargo
```

## no_std Readiness

`obex_primitives` supports `no_std` with `alloc`. Enable by disabling default features and opting into `alloc`:

```toml
[dependencies]
obex_primitives = { version = "0.1", default-features = false, features = ["alloc"] }
```

## CI

Recommended CI gates to enforce formatting, lints, determinism, and `no_std` readiness:

- Formatting: `cargo fmt --check`
- Clippy: `cargo clippy --all-targets --all-features -- -D warnings -W clippy::all -W clippy::pedantic -W clippy::nursery -W clippy::cargo`
- Tests: `cargo test --release --all-targets` and with feature `obex_alpha_i/ecvrf_rfc9381-ed25519`
- Determinism: run tests twice and diff outputs to assert byte-for-byte determinism
- no_std: build `obex_primitives` with `--no-default-features --features alloc` for an embedded target

## License

Dual licensed under MIT or Apacheâ€‘2.0, at your option.

## Status and Known Notes

- The ECVRF adapter (`obex_alpha_i::vrf`) is wired to `vrf-rfc9381` 0.0.3 using the `ECVRF-EDWARDS25519-SHA512-TAI` suite and enforces 32/80/64 byte lengths endâ€‘toâ€‘end. Consensus hashing uses SHA3â€‘256 only (domainâ€‘tagged) throughout Î± Î¹/Ï‘/Îº/Ï„. The VRF RFC 9381 TAI test vectors are integrated and passing.
  - The workspace does not expose binaries; it is a library suite with comprehensive unit and golden tests (including fixedâ€‘hex KATs for tags and header IDs).

### Gating tests present
- Î± I: VRF suite constant, wrongâ€‘length Î± rejection, random Ï€ rejection; oversize `ObexPartRec` rejected preâ€‘decode; participationâ€‘set dedup determinism
- Î± II: `part_root` flipâ€‘bit mismatch â†’ `ValidateErr::PartRootMismatch`; 3â€‘slot E2E header ID uniqueness
- Î± III: fee rule branches and admission state updates; emptyâ€‘slot ticket root equals empty tag
- Î± T: emission accumulator monotonicity; fee split cap respected; system tx codec roundtrip



rust-toolchain.toml
[toolchain]
channel = "stable"
components = ["clippy", "rustfmt"]


.cargo>config.toml
[build]
rustflags = ["-Dwarnings"]




.github>workflows>ci.yml
name: CI

on:
  push:
  pull_request:

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          components: rustfmt, clippy
          profile: minimal
      - name: fmt
        run: cargo fmt --all -- --check | cat
      - name: clippy
        run: cargo clippy --all-targets --all-features -- -D warnings -D clippy::pedantic -D clippy::nursery -D clippy::cargo | cat
      - name: test
        run: cargo test --all --all-targets | cat



crates>obex_alpha_i>Cargo.toml
[package]
name = "obex_alpha_i"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "Obex Î± I â€” Participation Engine (VRF-salted, RAM-hard)"
repository = "https://github.com/obex-labs/obex-alpha"
readme = "../../README.md"
keywords = ["obex","consensus","cryptography","vrf","merkle"]
categories = ["cryptography","algorithms","data-structures"]

[features]
default = ["ecvrf_rfc9381"]
# New canonical feature name (kept alongside legacy for compatibility)
ecvrf_rfc9381 = ["vrf-rfc9381/edwards25519", "sha2"]
# Legacy alias (CI/scripts may still reference this)
ecvrf_rfc9381-ed25519 = ["ecvrf_rfc9381"]

[dependencies]
obex_primitives = { path = "../obex_primitives" }
ed25519-dalek = { version = "2", default-features = false, features = ["alloc"] }
thiserror = "2.0"
vrf-rfc9381 = { version = "0.0.3", optional = true, default-features = false, features = ["edwards25519"] }
sha2 = { version = "0.10", optional = true }

[dev-dependencies]
hex = "0.4"
hex-literal = "0.4"




crates>obex_alpha_i>examples>gen_golden_partrec.rs
use std::fs;
use std::path::Path;

use obex_alpha_i::{encode_partrec, ChallengeOpen, MerklePathLite, ObexPartRec, OBEX_ALPHA_I_VERSION, CHALLENGES_Q};
use obex_primitives::{constants, h_tag, le_bytes, Hash256, Pk32};

fn main() {
    // Deterministic fixture: small, validly-shaped record with empty Merkle paths.
    let pk: Pk32 = [1u8; 32];
    let vrf_pk: [u8; 32] = [2u8; 32];
    let y_prev: Hash256 = [3u8; 32];
    let vrf_y: Vec<u8> = vec![5u8; 64];
    let parent_id = constants::GENESIS_PARENT_ID;
    let slot = 1u64;
    let alpha: Hash256 = h_tag(constants::TAG_ALPHA, &[&parent_id, &le_bytes::<8>(u128::from(slot)), &y_prev, &vrf_pk]);
    let seed: Hash256 = h_tag(constants::TAG_SEED, &[&y_prev, &pk, &vrf_y]);
    let root: Hash256 = h_tag(constants::TAG_MERKLE_EMPTY, &[]);

    let mut challenges = Vec::with_capacity(CHALLENGES_Q);
    for _ in 0..CHALLENGES_Q {
        challenges.push(ChallengeOpen {
            idx: 1,
            li: [9u8; 32],
            pi: MerklePathLite { siblings: vec![] },
            lim1: [10u8; 32],
            pim1: MerklePathLite { siblings: vec![] },
            lj: [11u8; 32],
            pj: MerklePathLite { siblings: vec![] },
            lk: [12u8; 32],
            pk_: MerklePathLite { siblings: vec![] },
        });
    }

    let rec = ObexPartRec {
        version: OBEX_ALPHA_I_VERSION,
        slot,
        pk_ed25519: pk,
        vrf_pk,
        y_edge_prev: y_prev,
        alpha,
        vrf_y,
        vrf_pi: vec![6u8; 80],
        seed,
        root,
        challenges,
        sig: [13u8; 64],
    };

    let bytes = encode_partrec(&rec).expect("encode");

    let out_dir = Path::new(env!("CARGO_MANIFEST_DIR")).join("tests").join("golden");
    fs::create_dir_all(&out_dir).expect("mkdir -p tests/golden");
    let out_path = out_dir.join("partrec_v1.bin");
    fs::write(&out_path, &bytes).expect("write golden partrec");
    println!("WROTE:{}", out_path.display());
}




crates>obex_alpha_i>src>lib.rs
#![forbid(unsafe_code)]
#![deny(
    warnings,
    clippy::all,
    clippy::pedantic,
    clippy::nursery,
    clippy::cargo
)]
#![allow(
    clippy::module_name_repetitions,
    clippy::missing_errors_doc,
    clippy::missing_panics_doc,
    clippy::result_large_err
)]

//! obex.Î± I â€” Participation Engine (VRF-salted, RAM-hard, byte-precise)
//!
//! This crate implements the verifier and builder functions specified in
//! `obex.alpha I.txt`. Cryptographic primitives (Ed25519 and ECVRF) are
//! integrated via vetted crates or pluggable trait providers.

use ed25519_dalek::{Signature, VerifyingKey};
use obex_primitives::{constants, ct_eq_hash, h_tag, le_bytes, merkle_root, merkle_verify_leaf, u64_from_le, Hash256, Pk32, Sig64};
use thiserror::Error;

/// Consensus constants (network versioned)
pub const OBEX_ALPHA_I_VERSION: u32 = 1;
pub const MEM_MIB: usize = 512; // target RAM per prover instance
pub const LABEL_BYTES: usize = 32; // SHA3-256 width
pub const N_LABELS: usize = (MEM_MIB * 1_048_576) / LABEL_BYTES; // 16,777,216
pub const PASSES: u32 = 3; // diffusion passes
pub const CHALLENGES_Q: usize = 96; // residual cheat â‰ˆ 2^-96
pub const MAX_PARTREC_SIZE: usize = 600_000; // DoS cap on serialized proof

/// VRF public key type (Ed25519 curve per RFC 9381 ECVRF-EDWARDS25519-SHA512-ELL2)
pub type VrfPk32 = [u8; 32];

/// Merkle path lite used within challenges
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct MerklePathLite {
    pub siblings: Vec<Hash256>,
}

/// Challenge opening as per spec (field order preserved)
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct ChallengeOpen {
    pub idx: u64,
    pub li: Hash256,
    pub pi: MerklePathLite,

    pub lim1: Hash256,
    pub pim1: MerklePathLite,

    pub lj: Hash256,
    pub pj: MerklePathLite,

    pub lk: Hash256,
    pub pk_: MerklePathLite,
}

/// Canonical `ObexPartRec` proof object
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct ObexPartRec {
    pub version: u32,
    pub slot: u64,
    pub pk_ed25519: Pk32,
    pub vrf_pk: VrfPk32,
    pub y_edge_prev: Hash256,
    pub alpha: Hash256,
    pub vrf_y: Vec<u8>, // 64 or 32 bytes (network-wide fixed)
    pub vrf_pi: Vec<u8>, // RFC 9381
    pub seed: Hash256,
    pub root: Hash256,
    pub challenges: Vec<ChallengeOpen>, // len == CHALLENGES_Q
    pub sig: Sig64, // Ed25519 over transcript
}

/// VRF verifier provider interface (pluggable for RFC 9381 ECVRF)
pub trait EcVrfVerifier {
    /// Verify (`vrf_pk`, `alpha`, `vrf_pi`) and return canonical `vrf_y` bytes (64 or network rehash 32).
    fn verify(&self, vrf_pubkey: &VrfPk32, alpha: &Hash256, vrf_proof: &[u8]) -> Option<Vec<u8>>;
}

#[cfg(any(feature = "ecvrf_rfc9381", feature = "ecvrf_rfc9381-ed25519"))]
pub mod vrf;

#[inline]
fn obex_alpha(parent_id: &Hash256, slot: u64, y_prev: &Hash256, vrf_pk: &VrfPk32) -> Hash256 {
    h_tag(constants::TAG_ALPHA, &[parent_id, &le_bytes::<8>(u128::from(slot)), y_prev, vrf_pk])
}

#[inline]
fn obex_seed(y_prev: &Hash256, pk: &Pk32, vrf_y: &[u8]) -> Hash256 {
    h_tag(constants::TAG_SEED, &[y_prev, pk, vrf_y])
}

#[inline]
#[allow(dead_code)]
fn lbl0(seed: &Hash256) -> Hash256 { h_tag(constants::TAG_L0, &[seed]) }

#[inline]
fn idx_j(seed: &Hash256, i: u64, p: u32) -> u64 {
    let b = h_tag(constants::TAG_IDX, &[seed, &le_bytes::<8>(u128::from(i)), &le_bytes::<4>(u128::from(p)), &[0x00]]);
    if i == 0 { 0 } else { u64_from_le(&b[..8]) % i }
}

#[inline]
fn idx_k(seed: &Hash256, i: u64, p: u32) -> u64 {
    let b = h_tag(constants::TAG_IDX, &[seed, &le_bytes::<8>(u128::from(i)), &le_bytes::<4>(u128::from(p)), &[0x01]]);
    if i == 0 { 0 } else { u64_from_le(&b[..8]) % i }
}

#[inline]
fn label_update(seed: &Hash256, i: u64, l_im1: &Hash256, l_j: &Hash256, l_k: &Hash256) -> Hash256 {
    h_tag(constants::TAG_LBL, &[seed, &le_bytes::<8>(u128::from(i)), l_im1, l_j, l_k])
}

#[inline]
fn chal_index(y_prev: &Hash256, root: &Hash256, vrf_y: &[u8], t: u32) -> u64 {
    let b = h_tag(constants::TAG_CHAL, &[y_prev, root, vrf_y, &le_bytes::<4>(u128::from(t))]);
    1 + (u64_from_le(&b[..8]) % ((N_LABELS as u64) - 1))
}

struct TranscriptParts<'a> {
    version: u32,
    slot: u64,
    pk: &'a Pk32,
    vrf_pk: &'a VrfPk32,
    y_prev: &'a Hash256,
    alpha: &'a Hash256,
    vrf_y: &'a [u8],
    root: &'a Hash256,
}

fn partrec_msg(p: &TranscriptParts<'_>) -> Hash256 {
    h_tag(constants::TAG_PARTREC, &[
        &le_bytes::<4>(u128::from(p.version)),
        p.pk,
        p.vrf_pk,
        &le_bytes::<8>(u128::from(p.slot)),
        p.y_prev,
        p.alpha,
        p.vrf_y,
        p.root,
    ])
}

fn verify_sig(pk: &Pk32, msg: &Hash256, sig: &Sig64) -> bool {
    // Ed25519 canonical verification via ed25519-dalek
    match (VerifyingKey::from_bytes(pk), Signature::from_slice(sig)) {
        (Ok(vk), Ok(sig_d)) => vk.verify_strict(msg, &sig_d).is_ok(),
        _ => false,
    }
}

/// Verify a received `ObexPartRec` for target slot `slot`.
#[must_use]
pub fn obex_verify_partrec(
    rec: &ObexPartRec,
    slot: u64,
    parent_id: &Hash256,
    vrf: &impl EcVrfVerifier,
) -> bool {
    if rec.version != OBEX_ALPHA_I_VERSION { return false; }
    if rec.slot != slot { return false; }
    if rec.challenges.len() != CHALLENGES_Q { return false; }

    // 1) VRF
    let alpha = obex_alpha(parent_id, slot, &rec.y_edge_prev, &rec.vrf_pk);
    if !ct_eq_hash(&alpha, &rec.alpha) { return false; }
    let Some(vrf_y_check) = vrf.verify(&rec.vrf_pk, &alpha, &rec.vrf_pi) else { return false };
    if vrf_y_check.as_slice() != rec.vrf_y.as_slice() { return false; }

    // 2) Seed
    let seed_expected = obex_seed(&rec.y_edge_prev, &rec.pk_ed25519, &rec.vrf_y);
    if !ct_eq_hash(&seed_expected, &rec.seed) { return false; }

    // 3) Signature
    let msg = partrec_msg(&TranscriptParts {
        version: rec.version,
        slot: rec.slot,
        pk: &rec.pk_ed25519,
        vrf_pk: &rec.vrf_pk,
        y_prev: &rec.y_edge_prev,
        alpha: &rec.alpha,
        vrf_y: &rec.vrf_y,
        root: &rec.root,
    });
    if !verify_sig(&rec.pk_ed25519, &msg, &rec.sig) { return false; }

    // 4) Challenges
    let last_pass = PASSES - 1;
    for (t, ch) in rec.challenges.iter().enumerate() {
        let Ok(t_u32) = u32::try_from(t) else { return false };
        let i = chal_index(&rec.y_edge_prev, &rec.root, &rec.vrf_y, t_u32);
        if ch.idx != i { return false; }
        if !(i > 0 && usize::try_from(i).is_ok_and(|ii| ii < N_LABELS)) { return false; }

        let j = idx_j(&rec.seed, i, last_pass);
        let k = idx_k(&rec.seed, i, last_pass);
        if !(j < i && k < i) { return false; }

        // Merkle paths
        if !merkle_verify_leaf(&rec.root, &ch.li,   &obex_primitives::MerklePath { siblings: ch.pi.siblings.clone(),   index: i }) { return false; }
        if !merkle_verify_leaf(&rec.root, &ch.lim1, &obex_primitives::MerklePath { siblings: ch.pim1.siblings.clone(), index: i - 1 }) { return false; }
        if !merkle_verify_leaf(&rec.root, &ch.lj,   &obex_primitives::MerklePath { siblings: ch.pj.siblings.clone(),   index: j }) { return false; }
        if !merkle_verify_leaf(&rec.root, &ch.lk,   &obex_primitives::MerklePath { siblings: ch.pk_.siblings.clone(),  index: k }) { return false; }

        // Label equation
        let li_check = label_update(&rec.seed, i, &ch.lim1, &ch.lj, &ch.lk);
        if !ct_eq_hash(&li_check, &ch.li) { return false; }
    }
    true
}

/// Build the participation set `P_s` and its commitment root for a slot, given an iterator of submissions.
#[must_use]
pub fn build_participation_set<'a>(
    slot: u64,
    parent_id: &Hash256,
    submissions: impl Iterator<Item = &'a ObexPartRec>,
    vrf: &impl EcVrfVerifier,
) -> (Vec<Pk32>, Hash256) {
    use std::collections::BTreeSet;
    let mut seen: BTreeSet<Pk32> = BTreeSet::new();
    let mut pks: Vec<Pk32> = Vec::new();

    for rec in submissions {
        if rec.slot != slot { continue; }
        if seen.contains(&rec.pk_ed25519) { continue; }
        if obex_verify_partrec(rec, slot, parent_id, vrf) {
            seen.insert(rec.pk_ed25519);
            pks.push(rec.pk_ed25519);
        }
    }
    pks.sort_unstable();

    // part_root = Merkle over H("obex.part.leaf",[]) || pk
    let leaves: Vec<Vec<u8>> = pks.iter().map(|pk| {
        let mut b = Vec::with_capacity(32 + 32);
        b.extend_from_slice(&h_tag(constants::TAG_PART_LEAF, &[]));
        b.extend_from_slice(pk);
        b
    }).collect();
    let part_root = merkle_root(&leaves);

    (pks, part_root)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn chal_index_monotonic_domain_bounds() {
        let y_prev = [1u8; 32];
        let root = [2u8; 32];
        let vrf_y = vec![3u8; 32];
        for t in 0..u32::try_from(CHALLENGES_Q).unwrap() {
            let i = super::chal_index(&y_prev, &root, &vrf_y, t);
            assert!(i > 0);
            assert!(usize::try_from(i).is_ok_and(|ii| ii < N_LABELS));
        }
    }
}

// â€”â€”â€” Canonical codecs (wire format) â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

#[derive(Debug, Error)]
pub enum CodecError {
    #[error("input too short")] Short,
    #[error("trailing bytes after decode")] Trailing,
    #[error("bad vector length")] BadLen,
    #[error("vrf_y must be 64 bytes")] BadVrfY,
    #[error("vrf_pi must be 80 bytes")] BadVrfPi,
    #[error("wrong challenges count")] BadChallenges,
}

const fn read_exact<'a>(src: &mut &'a [u8], n: usize) -> Result<&'a [u8], CodecError> {
    if src.len() < n { return Err(CodecError::Short); }
    let (a, b) = src.split_at(n);
    *src = b;
    Ok(a)
}

fn read_u32(src: &mut &[u8]) -> Result<u32, CodecError> {
    let b = read_exact(src, 4)?;
    Ok(u32::from_le_bytes(b.try_into().unwrap()))
}

fn read_u64(src: &mut &[u8]) -> Result<u64, CodecError> {
    let b = read_exact(src, 8)?;
    Ok(u64::from_le_bytes(b.try_into().unwrap()))
}

fn read_hash(src: &mut &[u8]) -> Result<Hash256, CodecError> {
    let b = read_exact(src, 32)?;
    let mut h = [0u8; 32];
    h.copy_from_slice(b);
    Ok(h)
}

// removed: read_len_prefixed_bytes (unused)

fn read_hash_vec(src: &mut &[u8]) -> Result<Vec<Hash256>, CodecError> {
    let n = read_u32(src)? as usize;
    let mut v = Vec::with_capacity(n);
    for _ in 0..n { v.push(read_hash(src)?); }
    Ok(v)
}

fn write_le<const W: usize>(out: &mut Vec<u8>, x: u128) { out.extend_from_slice(&le_bytes::<W>(x)); }
fn write_bytes(out: &mut Vec<u8>, b: &[u8]) { out.extend_from_slice(b); }
fn write_hash(out: &mut Vec<u8>, h: &Hash256) { out.extend_from_slice(h); }

fn encode_hash_vec(out: &mut Vec<u8>, v: &[Hash256]) {
    write_le::<4>(out, v.len() as u128);
    for h in v { write_hash(out, h); }
}

fn encode_challenge(out: &mut Vec<u8>, ch: &ChallengeOpen) {
    write_le::<8>(out, u128::from(ch.idx));
    write_hash(out, &ch.li);
    encode_hash_vec(out, &ch.pi.siblings);
    write_hash(out, &ch.lim1);
    encode_hash_vec(out, &ch.pim1.siblings);
    write_hash(out, &ch.lj);
    encode_hash_vec(out, &ch.pj.siblings);
    write_hash(out, &ch.lk);
    encode_hash_vec(out, &ch.pk_.siblings);
}

pub fn encode_partrec(rec: &ObexPartRec) -> Result<Vec<u8>, CodecError> {
    if rec.vrf_y.len() != 64 { return Err(CodecError::BadVrfY); }
    if rec.vrf_pi.len() != 80 { return Err(CodecError::BadVrfPi); }
    if rec.challenges.len() != CHALLENGES_Q { return Err(CodecError::BadChallenges); }
    let mut out = Vec::new();
    write_le::<4>(&mut out, u128::from(rec.version));
    write_le::<8>(&mut out, u128::from(rec.slot));
    write_bytes(&mut out, &rec.pk_ed25519);
    write_bytes(&mut out, &rec.vrf_pk);
    write_hash(&mut out, &rec.y_edge_prev);
    write_hash(&mut out, &rec.alpha);
    write_bytes(&mut out, &rec.vrf_y);
    write_bytes(&mut out, &rec.vrf_pi);
    write_hash(&mut out, &rec.seed);
    write_hash(&mut out, &rec.root);
    // challenges: LE(4) count then bodies
    write_le::<4>(&mut out, rec.challenges.len() as u128);
    for ch in &rec.challenges { encode_challenge(&mut out, ch); }
    write_bytes(&mut out, &rec.sig);
    Ok(out)
}

pub fn decode_partrec(mut src: &[u8]) -> Result<ObexPartRec, CodecError> {
    let version = read_u32(&mut src)?;
    let slot = read_u64(&mut src)?;
    let pk_ed25519 = {
        let b = read_exact(&mut src, 32)?; let mut a = [0u8; 32]; a.copy_from_slice(b); a
    };
    let vrf_pk = { let b = read_exact(&mut src, 32)?; let mut a = [0u8; 32]; a.copy_from_slice(b); a };
    let y_edge_prev = read_hash(&mut src)?;
    let alpha = read_hash(&mut src)?;
    let vrf_y = {
        let b = read_exact(&mut src, 64)?; b.to_vec()
    };
    let vrf_proof = { let b = read_exact(&mut src, 80)?; b.to_vec() };
    let seed = read_hash(&mut src)?;
    let root = read_hash(&mut src)?;
    let n_ch = read_u32(&mut src)? as usize;
    if n_ch != CHALLENGES_Q { return Err(CodecError::BadChallenges); }
    let mut challenges = Vec::with_capacity(n_ch);
    for _ in 0..n_ch {
        let idx = read_u64(&mut src)?;
        let li = read_hash(&mut src)?;
        let pi = obex_primitives::MerklePath { siblings: read_hash_vec(&mut src)?, index: 0 };
        let lim1 = read_hash(&mut src)?;
        let pim1 = obex_primitives::MerklePath { siblings: read_hash_vec(&mut src)?, index: 0 };
        let lj = read_hash(&mut src)?;
        let pj = obex_primitives::MerklePath { siblings: read_hash_vec(&mut src)?, index: 0 };
        let lk = read_hash(&mut src)?;
        let pk_ = obex_primitives::MerklePath { siblings: read_hash_vec(&mut src)?, index: 0 };
        challenges.push(ChallengeOpen { idx, li, pi: MerklePathLite { siblings: pi.siblings }, lim1, pim1: MerklePathLite { siblings: pim1.siblings }, lj, pj: MerklePathLite { siblings: pj.siblings }, lk, pk_: MerklePathLite { siblings: pk_.siblings } });
    }
    let sig = { let b = read_exact(&mut src, 64)?; let mut s = [0u8; 64]; s.copy_from_slice(b); s };
    if !src.is_empty() { return Err(CodecError::Trailing); }
    Ok(ObexPartRec { version, slot, pk_ed25519, vrf_pk, y_edge_prev, alpha, vrf_y, vrf_pi: vrf_proof, seed, root, challenges, sig })
}

/// Verify directly from canonical bytes with `MAX_PARTREC_SIZE` enforcement before heavy work.
pub fn obex_verify_partrec_bytes(
    bytes: &[u8],
    slot: u64,
    parent_id: &Hash256,
    vrf: &impl EcVrfVerifier,
) -> bool {
    if bytes.len() > MAX_PARTREC_SIZE { return false; }
    let Ok(rec) = decode_partrec(bytes) else { return false };
    obex_verify_partrec(&rec, slot, parent_id, vrf)
}




crates>obex_alpha_i>src>vrf.rs
#![allow(clippy::missing_inline_in_public_items)]

// obex_alpha_i::vrf â€” RFC 9381 ECVRF adapter (ED25519 + SHA-512 + ELL2)
// Consensus-normative: lengths and suite are hard-coded.

#[cfg(any(feature = "ecvrf_rfc9381", feature = "ecvrf_rfc9381-ed25519"))]
mod rfc9381 {
    use core::fmt;
    use sha2::Sha512;
    use vrf_rfc9381::ec::edwards25519::{tai::EdVrfEdwards25519TaiPublicKey, EdVrfProof};
    use vrf_rfc9381::Verifier as _;

    pub const VRF_SUITE_NAME: &str = "ECVRF-EDWARDS25519-SHA512-TAI";
    pub const VRF_PK_BYTES: usize = 32;  // public key
    pub const VRF_PI_BYTES: usize = 80;  // proof Ï€
    pub const VRF_Y_BYTES: usize = 64;  // output Î²

    pub type VrfPk = [u8; VRF_PK_BYTES];
    pub type VrfPi = [u8; VRF_PI_BYTES];
    pub type VrfY  = [u8; VRF_Y_BYTES];

    #[derive(Clone, Copy, Debug, Eq, PartialEq)]
    pub enum VrfError { BadPublicKey, BadProofEncoding, VerificationFailed }
    impl fmt::Display for VrfError {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            match self {
                Self::BadPublicKey => f.write_str("malformed or non-canonical VRF public key"),
                Self::BadProofEncoding => f.write_str("malformed VRF proof encoding"),
                Self::VerificationFailed => f.write_str("VRF verification failed"),
            }
        }
    }

    #[inline]
    pub fn verify(vrf_pk: &VrfPk, alpha: &[u8], pi: &VrfPi) -> Result<VrfY, VrfError> {
        if alpha.len() != 32 { return Err(VrfError::VerificationFailed); }
        let vk = EdVrfEdwards25519TaiPublicKey::from_slice(vrf_pk).map_err(|_| VrfError::BadPublicKey)?;
        let proof = <EdVrfProof as vrf_rfc9381::Proof<Sha512>>::decode_pi(pi).map_err(|_| VrfError::BadProofEncoding)?;
        let out = vk.verify(alpha, proof).map_err(|_| VrfError::VerificationFailed)?;
        let mut y = [0u8; VRF_Y_BYTES];
        y.copy_from_slice(out.as_slice());
        Ok(y)
    }

    /// Verify for arbitrary-length alpha message (RFC vectors). Not used in consensus.
    #[inline]
    pub fn verify_msg_tai(vrf_pk: &VrfPk, alpha_msg: &[u8], pi: &VrfPi) -> Result<VrfY, VrfError> {
        let vk = EdVrfEdwards25519TaiPublicKey::from_slice(vrf_pk).map_err(|_| VrfError::BadPublicKey)?;
        let proof = <EdVrfProof as vrf_rfc9381::Proof<Sha512>>::decode_pi(pi).map_err(|_| VrfError::BadProofEncoding)?;
        let out = vk.verify(alpha_msg, proof).map_err(|_| VrfError::VerificationFailed)?;
        let mut y = [0u8; VRF_Y_BYTES];
        y.copy_from_slice(out.as_slice());
        Ok(y)
    }
}

#[cfg(any(feature = "ecvrf_rfc9381", feature = "ecvrf_rfc9381-ed25519"))]
pub use rfc9381::{
    verify, verify_msg_tai, VrfError, VrfPk, VrfPi, VrfY, VRF_SUITE_NAME, VRF_PK_BYTES, VRF_PI_BYTES, VRF_Y_BYTES,
};

/// Convenience wrapper with explicit TAI naming used by tests/vectors.
#[inline]
pub fn ecvrf_verify_beta_tai(vrf_pk: &VrfPk, alpha: &[u8; 32], pi: &VrfPi) -> Result<VrfY, VrfError> {
    verify(vrf_pk, alpha, pi)
}

/// Variant used for RFC vectors with arbitrary-length alpha messages.
#[inline]
pub fn ecvrf_verify_beta_tai_msg(vrf_pk: &VrfPk, alpha_msg: &[u8], pi: &VrfPi) -> Result<VrfY, VrfError> {
    verify_msg_tai(vrf_pk, alpha_msg, pi)
}



crates>obex_alpha_i>tests>gating.rs
use obex_alpha_i::{obex_verify_partrec_bytes, EcVrfVerifier};
use obex_primitives::{Hash256};

struct RejectAllVrf;
impl EcVrfVerifier for RejectAllVrf {
    fn verify(&self, _vrf_pubkey: &[u8;32], _alpha: &Hash256, _vrf_proof: &[u8]) -> Option<Vec<u8>> { None }
}

#[test]
fn oversize_partrec_rejected_predecode() {
    // Construct a too-large buffer (over MAX_PARTREC_SIZE)
    let bytes = vec![0u8; 600_001];
    let slot = 1u64;
    let parent_id = [0u8;32];
    let vrf = RejectAllVrf;
    assert!(!obex_verify_partrec_bytes(&bytes, slot, &parent_id, &vrf));
}

#[test]
fn build_participation_set_dedups_by_pk() {
    use obex_alpha_i::{ObexPartRec, CHALLENGES_Q, OBEX_ALPHA_I_VERSION, build_participation_set};
    use obex_primitives::Pk32;
    struct AcceptAllVrf; impl EcVrfVerifier for AcceptAllVrf {
        fn verify(&self, _vrf_pubkey: &Pk32, _alpha: &Hash256, _vrf_proof: &[u8]) -> Option<Vec<u8>> { Some(vec![1u8;64]) }
    }

    // Minimal well-formed records with same sender pk, should dedup
    let mk = |pk: Pk32| ObexPartRec {
        version: OBEX_ALPHA_I_VERSION,
        slot: 1,
        pk_ed25519: pk,
        vrf_pk: [2u8;32],
        y_edge_prev: [3u8;32],
        alpha: [4u8;32],
        vrf_y: vec![5u8;64],
        vrf_pi: vec![6u8;80],
        seed: [7u8;32],
        root: [8u8;32],
        challenges: (0..CHALLENGES_Q).map(|_| obex_alpha_i::ChallengeOpen{ idx:1, li:[9;32], pi: obex_alpha_i::MerklePathLite{ siblings: vec![]}, lim1:[10;32], pim1: obex_alpha_i::MerklePathLite{ siblings: vec![]}, lj:[11;32], pj: obex_alpha_i::MerklePathLite{ siblings: vec![]}, lk:[12;32], pk_: obex_alpha_i::MerklePathLite{ siblings: vec![]} }).collect(),
        sig: [13u8;64],
    };
    let a = mk([1u8;32]);
    let b = mk([1u8;32]); // same pk
    let (_pks, root1) = build_participation_set(1, &[0u8;32], [a.clone(), b].iter(), &AcceptAllVrf);
    let (_pks2, root2) = build_participation_set(1, &[0u8;32], std::iter::once(&a), &AcceptAllVrf);
    assert_eq!(root1, root2);
}



crates>obex_alpha_i>tests>golden.rs
#![allow(unused)]
use obex_alpha_i::{encode_partrec, decode_partrec, ObexPartRec, ChallengeOpen, MerklePathLite, OBEX_ALPHA_I_VERSION, CHALLENGES_Q};
use hex::ToHex;

#[test]
fn partrec_golden_roundtrip() {
    let mut challenges = Vec::with_capacity(CHALLENGES_Q);
    for _ in 0..CHALLENGES_Q {
        challenges.push(ChallengeOpen {
            idx: 1,
            li: [9u8;32],
            pi: MerklePathLite { siblings: vec![] },
            lim1: [10u8;32],
            pim1: MerklePathLite { siblings: vec![] },
            lj: [11u8;32],
            pj: MerklePathLite { siblings: vec![] },
            lk: [12u8;32],
            pk_: MerklePathLite { siblings: vec![] },
        });
    }
    let rec = ObexPartRec {
        version: OBEX_ALPHA_I_VERSION,
        slot: 1,
        pk_ed25519: [1u8;32],
        vrf_pk: [2u8;32],
        y_edge_prev: [3u8;32],
        alpha: [4u8;32],
        vrf_y: vec![5u8;64],
        vrf_pi: vec![6u8;80],
        seed: [7u8;32],
        root: [8u8;32],
        challenges,
        sig: [13u8;64],
    };
    let bytes = encode_partrec(&rec).expect("encode");
    let rec2 = decode_partrec(&bytes).expect("decode");
    assert_eq!(rec2.version, rec.version);
    assert_eq!(rec2.slot, rec.slot);
    assert_eq!(rec2.pk_ed25519, rec.pk_ed25519);
    assert_eq!(rec2.vrf_pk, rec.vrf_pk);
    assert_eq!(rec2.vrf_y, rec.vrf_y);
    assert_eq!(rec2.vrf_pi.len(), 80);
    assert_eq!(rec2.challenges.len(), CHALLENGES_Q);
    // Byte-for-byte stability: re-encode equals original
    let bytes2 = encode_partrec(&rec2).expect("encode2");
    assert_eq!(bytes2, bytes);
    // Provide a hex digest KAT (length only here to avoid freezing values prematurely)
    let hex = bytes.encode_hex::<String>();
    assert!(!hex.is_empty());
}




crates>obex_alpha_i>tests>golden_partrec.rs
use std::fs;
use std::path::Path;

use obex_alpha_i::{decode_partrec, encode_partrec};

fn read_golden() -> Vec<u8> {
    let p = Path::new(env!("CARGO_MANIFEST_DIR")).join("tests").join("golden").join("partrec_v1.bin");
    fs::read(p).expect("read golden partrec_v1.bin")
}

#[test]
fn golden_partrec_accept_and_roundtrip() {
    let bytes = read_golden();
    let rec = decode_partrec(&bytes).expect("decode golden");
    let bytes2 = encode_partrec(&rec).expect("re-encode");
    assert_eq!(bytes2, bytes, "golden bytes stable");
}

#[test]
fn golden_partrec_flipbit_failures() {
    let bytes = read_golden();
    for i in [0usize, 4, 12, 40, 80, 112, bytes.len() - 1] {
        let mut b = bytes.clone();
        b[i] ^= 1;
        let _ = decode_partrec(&b).ok();
        // For now we assert inequality to the original bytes upon re-encode when decodable.
        if let Ok(rec) = decode_partrec(&b) {
            let enc = encode_partrec(&rec).expect("enc");
            assert_ne!(enc, bytes, "flip-bit should change the canonical encoding");
        }
    }
}




crates>obex_alpha_i>tests>vrf_kats.rs
#![cfg(any(feature = "ecvrf_rfc9381", feature = "ecvrf_rfc9381-ed25519"))]
use obex_alpha_i::vrf;

// KATs: enforce length rejects and round-trip against underlying prover for TAI.
#[test]
fn vrf_kat_lengths_and_rejects() {
    let pk = [0u8; vrf::VRF_PK_BYTES];
    let alpha = [1u8; 32];
    let pi = [2u8; vrf::VRF_PI_BYTES];
    // Wrong alpha length
    assert!(vrf::verify(&pk, &[0u8; 31], &pi).is_err());
    // Random Ï€ should reject
    assert!(vrf::verify(&pk, &alpha, &pi).is_err());
}


// (RFC 9381 vector tests can be added by adapting crate API; kept minimal here.)




crates>obex_alpha_i>tests>vrf_rfc9381_tai.rs
#![cfg(any(feature = "ecvrf_rfc9381", feature = "ecvrf_rfc9381-ed25519"))]
#![allow(non_snake_case)]

use obex_alpha_i::vrf::ecvrf_verify_beta_tai_msg;

struct V { vk: &'static str, alpha_hex: &'static str, pi: &'static str, beta: &'static str }

const VECTORS: &[V] = &[
    V{
        vk: "d75a980182b10ab7d54bfed3c964073a0ee172f3daa62325af021a68f707511a",
        alpha_hex: "",
        pi: "8657106690b5526245a92b003bb079ccd1a92130477671f6fc01ad16f26f723f26f8a57ccaed74ee1b190bed1f479d9727d2d0f9b005a6e456a35d4fb0daab1268a1b0db10836d9826a528ca76567805",
        beta: "90cf1df3b703cce59e2a35b925d411164068269d7b2d29f3301c03dd757876ff66b71dda49d2de59d03450451af026798e8f81cd2e333de5cdf4f3e140fdd8ae",
    },
    V{
        vk: "3d4017c3e843895a92b70aa74d1b7ebc9c982ccf2ec4968cc0cd55f12af4660c",
        alpha_hex: "72",
        pi: "f3141cd382dc42909d19ec5110469e4feae18300e94f304590abdced48aed5933bf0864a62558b3ed7f2fea45c92a465301b3bbf5e3e54ddf2d935be3b67926da3ef39226bbc355bdc9850112c8f4b02",
        beta: "eb4440665d3891d668e7e0fcaf587f1b4bd7fbfe99d0eb2211ccec90496310eb5e33821bc613efb94db5e5b54c70a848a0bef4553a41befc57663b56373a5031",
    },
    V{
        vk: "fc51cd8e6218a1a38da47ed00230f0580816ed13ba3303ac5deb911548908025",
        alpha_hex: "af82",
        pi: "9bc0f79119cc5604bf02d23b4caede71393cedfbb191434dd016d30177ccbf8096bb474e53895c362d8628ee9f9ea3c0e52c7a5c691b6c18c9979866568add7a2d41b00b05081ed0f58ee5e31b3a970e",
        beta: "645427e5d00c62a23fb703732fa5d892940935942101e456ecca7bb217c61c452118fec1219202a0edcf038bb6373241578be7217ba85a2687f7a0310b2df19f",
    },
];

fn hex_to_bytes(s: &str) -> Vec<u8> {
    if s.is_empty() { return vec![]; }
    (0..s.len()).step_by(2).map(|i| u8::from_str_radix(&s[i..i+2], 16).unwrap()).collect()
}

#[test]
fn rfc9381_tai_vectors_verify() {
    for v in VECTORS {
        let vk = hex_to_bytes(v.vk);
        let alpha = hex_to_bytes(v.alpha_hex);
        let pi = hex_to_bytes(v.pi);
        let beta = hex_to_bytes(v.beta);
        let out = ecvrf_verify_beta_tai_msg(&vk.clone().try_into().unwrap(), &alpha, &pi.clone().try_into().unwrap()).expect("verify ok");
        assert_eq!(out.as_slice(), beta.as_slice(), "beta mismatch for vk {}", v.vk);
        assert_eq!(beta.len(), 64);
        assert_eq!(pi.len(), 80);
    }
}




crates>obex_alpha_i>tests>vrf_vectors.rs
#![cfg(any(feature = "ecvrf_rfc9381", feature = "ecvrf_rfc9381-ed25519"))]
use obex_alpha_i::vrf;

#[test]
fn vrf_suite_constant() {
    assert_eq!(vrf::VRF_SUITE_NAME, "ECVRF-EDWARDS25519-SHA512-TAI");
}

#[test]
fn vrf_rejects_wrong_alpha_len() {
    let pk = [3u8; vrf::VRF_PK_BYTES];
    let pi = [4u8; vrf::VRF_PI_BYTES];
    // alpha must be exactly 32 bytes
    assert!(vrf::verify(&pk, &[1u8; 31], &pi).is_err());
}

#[test]
fn vrf_rejects_random_pi() {
    let pk = [7u8; vrf::VRF_PK_BYTES];
    let pi = [9u8; vrf::VRF_PI_BYTES];
    let alpha = [5u8; 32];
    // Random proof should fail verification under TAI
    assert!(vrf::verify(&pk, &alpha, &pi).is_err());
}



crates>obex_alpha_i>tests>golden>partrec_v1.bin
          qéó´â"¬Øé„
uèñÀX—˜Ýú£=Ýœ š˜ =DŽÑÊo #Œ‚G;ÈÀ›ÆýPöea'ÍðâÝÿ+%J¬Ô<SwÈû#mî`<åí>q2³í*;¶"…~`          																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































                   																																    































            

crates>obex_alpha_ii>Cargo.toml
[package]
name = "obex_alpha_ii"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "Obex Î± II â€” Deterministic Header Engine (forkless by equalities)"
repository = "https://github.com/obex-labs/obex-alpha"
readme = "../../README.md"
keywords = ["obex","consensus","header","merkle"]
categories = ["cryptography","algorithms","data-structures"]

[dependencies]
obex_primitives = { path = "../obex_primitives" }
thiserror = "2.0"

[dev-dependencies]
hex = "0.4"




crates>obex_alpha_ii>examples>gen_golden_header.rs
use std::fs;
use std::path::Path;

use hex::ToHex;
use obex_alpha_ii::{build_header, serialize_header, obex_header_id, Header, OBEX_ALPHA_II_VERSION, PartRootProvider, TicketRootProvider, TxRootProvider};
use obex_primitives::{constants, h_tag, le_bytes, Hash256};

fn empty_root() -> Hash256 { h_tag(constants::TAG_MERKLE_EMPTY, &[]) }

struct EmptyPartRoot; impl PartRootProvider for EmptyPartRoot { fn compute_part_root(&self, _slot: u64) -> Hash256 { empty_root() } }
struct EmptyTicketRoot; impl TicketRootProvider for EmptyTicketRoot { fn compute_ticket_root(&self, _slot: u64) -> Hash256 { empty_root() } }
struct EmptyTxRoot; impl TxRootProvider for EmptyTxRoot { fn compute_txroot(&self, _slot: u64) -> Hash256 { empty_root() } }

fn mk_parent() -> Header {
    let parent_id = [0u8; 32];
    let slot = 0u64;
    let seed_commit = h_tag(constants::TAG_SLOT_SEED, &[&parent_id, &le_bytes::<8>(slot as u128)]);
    let vdf_y_core = h_tag(constants::TAG_VDF_YCORE, &[&[1u8; 32]]);
    let vdf_y_edge = h_tag(constants::TAG_VDF_EDGE, &[&vdf_y_core]);
    Header {
        parent_id,
        slot,
        obex_version: OBEX_ALPHA_II_VERSION,
        seed_commit,
        vdf_y_core,
        vdf_y_edge,
        vdf_pi: vec![],
        vdf_ell: vec![],
        ticket_root: empty_root(),
        part_root: empty_root(),
        txroot_prev: empty_root(),
    }
}

fn main() {
    let parent = mk_parent();
    let s = parent.slot + 1;
    let seed_commit = h_tag(constants::TAG_SLOT_SEED, &[&obex_header_id(&parent), &le_bytes::<8>(s as u128)]);
    let y_core = h_tag(constants::TAG_VDF_YCORE, &[&[2u8; 32]]);
    let y_edge = h_tag(constants::TAG_VDF_EDGE, &[&y_core]);

    let ticket_roots = EmptyTicketRoot;
    let part_roots = EmptyPartRoot;
    let tx_roots = EmptyTxRoot;

    let child = build_header(&parent, (seed_commit, y_core, y_edge, vec![], vec![]), &ticket_roots, &part_roots, &tx_roots, OBEX_ALPHA_II_VERSION);

    let out_dir = Path::new(env!("CARGO_MANIFEST_DIR")).join("tests").join("golden");
    fs::create_dir_all(&out_dir).expect("mkdir -p tests/golden");

    let parent_path = out_dir.join("header_v2_parent.bin");
    let child_path = out_dir.join("header_v2_slot1.bin");
    fs::write(&parent_path, serialize_header(&parent)).expect("write parent header bin");
    fs::write(&child_path, serialize_header(&child)).expect("write child header bin");

    let id_hex = obex_header_id(&child).encode_hex::<String>();
    fs::write(out_dir.join("header_v2_slot1.id.hex"), id_hex.as_bytes()).expect("write id hex");

    println!("WROTE:{},{}", parent_path.display(), child_path.display());
}




crates>obex_alpha_ii>src>lib.rs
#![forbid(unsafe_code)]
#![deny(
    warnings,
    clippy::all,
    clippy::pedantic,
    clippy::nursery,
    clippy::cargo
)]
#![allow(
    clippy::module_name_repetitions,
    clippy::missing_errors_doc,
    clippy::missing_panics_doc,
    clippy::result_large_err
)]

//! obex.Î± II â€” Deterministic Header Engine (forkless by equalities)
//!
//! Implements the canonical header structure, identity hash, builder, and validator
//! per `obex.alpha II.txt`. Providers for beacon, participation, admission, and tx roots
//! are passed via traits.

use obex_primitives::{constants, ct_eq_hash, h_tag, le_bytes, Hash256};
use thiserror::Error;

/// Network version (consensus-sealed)
pub const OBEX_ALPHA_II_VERSION: u32 = 2;
/// Consensus size caps for beacon fields (deployment-defined; enforced before verification).
pub const MAX_PI_LEN: usize = 1_048_576;  // example: 1 MiB
pub const MAX_ELL_LEN: usize = 65_536;    // example: 64 KiB

/// Providers (adapters) for equality checks
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct BeaconInputs<'a> {
    pub parent_id: &'a Hash256,
    pub slot: u64,
    pub seed_commit: &'a Hash256,
    pub vdf_y_core: &'a Hash256,
    pub vdf_y_edge: &'a Hash256,
    pub vdf_pi: &'a [u8],
    pub vdf_ell: &'a [u8],
}

pub trait BeaconVerifier { fn verify(&self, inputs: &BeaconInputs<'_>) -> bool; }

pub trait TicketRootProvider { fn compute_ticket_root(&self, slot: u64) -> Hash256; }
pub trait PartRootProvider   { fn compute_part_root(&self, slot: u64) -> Hash256; }
pub trait TxRootProvider     { fn compute_txroot(&self, slot: u64) -> Hash256; }

/// Canonical header object
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct Header {
    pub parent_id: Hash256,
    pub slot: u64,
    pub obex_version: u32,

    // Beacon (VDF)
    pub seed_commit: Hash256,
    pub vdf_y_core: Hash256,
    pub vdf_y_edge: Hash256,
    pub vdf_pi: Vec<u8>,
    pub vdf_ell: Vec<u8>,

    // Deterministic commitments
    pub ticket_root: Hash256,
    pub part_root: Hash256,
    pub txroot_prev: Hash256,
}

/// Canonical header ID over field values (not transport bytes)
#[must_use]
pub fn obex_header_id(h: &Header) -> Hash256 {
    h_tag(constants::TAG_HEADER_ID, &[
        &h.parent_id,
        &le_bytes::<8>(u128::from(h.slot)),
        &le_bytes::<4>(u128::from(h.obex_version)),

        &h.seed_commit,
        &h.vdf_y_core,
        &h.vdf_y_edge,
        &le_bytes::<4>(h.vdf_pi.len() as u128),
        &h.vdf_pi,
        &le_bytes::<4>(h.vdf_ell.len() as u128),
        &h.vdf_ell,

        &h.ticket_root,
        &h.part_root,
        &h.txroot_prev,
    ])
}

// â€”â€”â€” Canonical header serializer/deserializer (wire layout Â§4.1) â€”â€”â€”â€”

#[derive(Debug, Error)]
pub enum CodecError { #[error("short input")] Short, #[error("trailing")] Trailing }

const fn read_exact<'a>(src: &mut &'a [u8], n: usize) -> Result<&'a [u8], CodecError> {
    if src.len() < n { return Err(CodecError::Short); }
    let (a,b) = src.split_at(n); *src = b; Ok(a)
}

#[must_use]
pub fn serialize_header(h: &Header) -> Vec<u8> {
    let mut out = Vec::new();
    out.extend_from_slice(&h.parent_id);
    out.extend_from_slice(&le_bytes::<8>(u128::from(h.slot)));
    out.extend_from_slice(&le_bytes::<4>(u128::from(h.obex_version)));

    out.extend_from_slice(&h.seed_commit);
    out.extend_from_slice(&h.vdf_y_core);
    out.extend_from_slice(&h.vdf_y_edge);
    out.extend_from_slice(&le_bytes::<4>(h.vdf_pi.len() as u128));
    out.extend_from_slice(&h.vdf_pi);
    out.extend_from_slice(&le_bytes::<4>(h.vdf_ell.len() as u128));
    out.extend_from_slice(&h.vdf_ell);

    out.extend_from_slice(&h.ticket_root);
    out.extend_from_slice(&h.part_root);
    out.extend_from_slice(&h.txroot_prev);
    out
}

pub fn deserialize_header(mut src: &[u8]) -> Result<Header, CodecError> {
    let parent_id = { let b = read_exact(&mut src, 32)?; let mut a = [0u8;32]; a.copy_from_slice(b); a };
    let slot      = u64::from_le_bytes(read_exact(&mut src, 8)?.try_into().unwrap());
    let obex_version = u32::from_le_bytes(read_exact(&mut src, 4)?.try_into().unwrap());
    let seed_commit = { let b = read_exact(&mut src, 32)?; let mut a = [0u8;32]; a.copy_from_slice(b); a };
    let vdf_y_core  = { let b = read_exact(&mut src, 32)?; let mut a = [0u8;32]; a.copy_from_slice(b); a };
    let vdf_y_edge  = { let b = read_exact(&mut src, 32)?; let mut a = [0u8;32]; a.copy_from_slice(b); a };
    let pi_len = u32::from_le_bytes(read_exact(&mut src, 4)?.try_into().unwrap()) as usize;
    let vdf_pi = read_exact(&mut src, pi_len)?.to_vec();
    let ell_len = u32::from_le_bytes(read_exact(&mut src, 4)?.try_into().unwrap()) as usize;
    let vdf_ell = read_exact(&mut src, ell_len)?.to_vec();
    let ticket_root = { let b = read_exact(&mut src, 32)?; let mut a = [0u8;32]; a.copy_from_slice(b); a };
    let part_root   = { let b = read_exact(&mut src, 32)?; let mut a = [0u8;32]; a.copy_from_slice(b); a };
    let txroot_prev = { let b = read_exact(&mut src, 32)?; let mut a = [0u8;32]; a.copy_from_slice(b); a };
    if !src.is_empty() { return Err(CodecError::Trailing); }
    Ok(Header { parent_id, slot, obex_version, seed_commit, vdf_y_core, vdf_y_edge, vdf_pi, vdf_ell, ticket_root, part_root, txroot_prev })
}

/// Build the canonical header for slot s = parent.slot + 1.
#[must_use]
pub fn build_header(
    parent: &Header,
    beacon_fields: (Hash256, Hash256, Hash256, Vec<u8>, Vec<u8>),
    ticket_roots: &impl TicketRootProvider,
    part_roots: &impl PartRootProvider,
    tx_roots: &impl TxRootProvider,
    obex_version: u32,
) -> Header {
    let s = parent.slot + 1;
    let (seed_commit, y_core, y_edge, pi, ell) = beacon_fields;

    let ticket_root = ticket_roots.compute_ticket_root(s);
    let part_root = part_roots.compute_part_root(s);
    let txroot_prev = tx_roots.compute_txroot(parent.slot);

    Header {
        parent_id: obex_header_id(parent),
        slot: s,
        obex_version,
        seed_commit,
        vdf_y_core: y_core,
        vdf_y_edge: y_edge,
        vdf_pi: pi,
        vdf_ell: ell,
        ticket_root,
        part_root,
        txroot_prev,
    }
}

/// Validation errors
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ValidateErr {
    BadParentLink,
    BadSlotProgression,
    BeaconInvalid,
    TicketRootMismatch,
    PartRootMismatch,
    TxRootPrevMismatch,
    VersionMismatch,
}

/// Validate a candidate header against deterministic equalities.
pub fn validate_header(
    h: &Header,
    parent: &Header,
    beacon: &impl BeaconVerifier,
    ticket_roots: &impl TicketRootProvider,
    part_roots: &impl PartRootProvider,
    tx_roots: &impl TxRootProvider,
    expected_version: u32,
) -> Result<(), ValidateErr> {
    // 1) Parent linkage & slot progression
    let parent_id_expected = obex_header_id(parent);
    if !ct_eq_hash(&h.parent_id, &parent_id_expected) { return Err(ValidateErr::BadParentLink); }
    if h.slot != parent.slot + 1 { return Err(ValidateErr::BadSlotProgression); }

    // 2) Beacon equality & caps (size first)
    if h.vdf_pi.len() > MAX_PI_LEN || h.vdf_ell.len() > MAX_ELL_LEN {
    return Err(ValidateErr::BeaconInvalid);
    }
    if !beacon.verify(&BeaconInputs {
        parent_id: &h.parent_id,
        slot: h.slot,
        seed_commit: &h.seed_commit,
        vdf_y_core: &h.vdf_y_core,
        vdf_y_edge: &h.vdf_y_edge,
        vdf_pi: &h.vdf_pi,
        vdf_ell: &h.vdf_ell,
    }) {
        return Err(ValidateErr::BeaconInvalid);
    }

    // 3) Admission equality (slot s)
    let ticket_root_local = ticket_roots.compute_ticket_root(h.slot);
    if !ct_eq_hash(&h.ticket_root, &ticket_root_local) { return Err(ValidateErr::TicketRootMismatch); }

    // 4) Participation equality (slot s)
    let part_root_local = part_roots.compute_part_root(h.slot);
    if !ct_eq_hash(&h.part_root, &part_root_local) { return Err(ValidateErr::PartRootMismatch); }

    // 5) Execution equality (slot s-1)
    let txroot_prev_local = tx_roots.compute_txroot(parent.slot);
    if !ct_eq_hash(&h.txroot_prev, &txroot_prev_local) { return Err(ValidateErr::TxRootPrevMismatch); }

    // 6) Version equality
    if h.obex_version != expected_version { return Err(ValidateErr::VersionMismatch); }

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    struct BeaconOk;
    impl BeaconVerifier for BeaconOk { fn verify(&self, _inputs: &BeaconInputs<'_>) -> bool { true } }
    struct ZeroRoot;
    impl TicketRootProvider for ZeroRoot { fn compute_ticket_root(&self, _slot: u64) -> Hash256 { [0u8; 32] } }
    impl PartRootProvider   for ZeroRoot { fn compute_part_root(&self, _slot: u64) -> Hash256 { [0u8; 32] } }
    impl TxRootProvider     for ZeroRoot { fn compute_txroot(&self, _slot: u64) -> Hash256 { [0u8; 32] } }

    #[test]
    fn header_build_and_validate_roundtrip() {
        let parent = Header {
            parent_id: [9u8; 32],
            slot: 7,
            obex_version: OBEX_ALPHA_II_VERSION,
            seed_commit: [1u8; 32],
            vdf_y_core: [2u8; 32],
            vdf_y_edge: [3u8; 32],
            vdf_pi: vec![],
            vdf_ell: vec![],
            ticket_root: [0u8; 32],
            part_root: [0u8; 32],
            txroot_prev: [0u8; 32],
        };
        let providers = ZeroRoot;
        let h = build_header(
            &parent,
            ([4u8; 32], [5u8; 32], [6u8; 32], vec![], vec![]),
            &providers,
            &providers,
            &providers,
            OBEX_ALPHA_II_VERSION,
        );
        let beacon = BeaconOk;
        assert!(validate_header(&h, &parent, &beacon, &providers, &providers, &providers, OBEX_ALPHA_II_VERSION).is_ok());
    }
}




crates>obex_alpha_ii>tests>e2e.rs
use obex_alpha_ii::{
    build_header, obex_header_id, validate_header, BeaconInputs, BeaconVerifier, Header,
    PartRootProvider, TicketRootProvider, TxRootProvider, ValidateErr, OBEX_ALPHA_II_VERSION,
};
use obex_primitives::{constants, h_tag, le_bytes, Hash256};

fn empty_root() -> Hash256 { h_tag(constants::TAG_MERKLE_EMPTY, &[]) }

struct BeaconOk;
impl BeaconVerifier for BeaconOk {
    fn verify(&self, i: &BeaconInputs<'_>) -> bool {
        let seed_expected = h_tag(constants::TAG_SLOT_SEED, &[i.parent_id, &le_bytes::<8>(i.slot as u128)]);
        seed_expected == *i.seed_commit
            && h_tag(constants::TAG_VDF_EDGE, &[i.vdf_y_core]) == *i.vdf_y_edge
    }
}

struct EmptyPartRoot;
impl PartRootProvider for EmptyPartRoot {
    fn compute_part_root(&self, _slot: u64) -> Hash256 { empty_root() }
}

struct EmptyTicketRoot;
impl TicketRootProvider for EmptyTicketRoot {
    fn compute_ticket_root(&self, _slot: u64) -> Hash256 { empty_root() }
}

struct EmptyTxRoot;
impl TxRootProvider for EmptyTxRoot {
    fn compute_txroot(&self, _slot: u64) -> Hash256 { empty_root() }
}

fn mk_parent() -> Header {
    let parent_id = [0u8; 32];
    let slot = 0u64;
    let seed_commit = h_tag(constants::TAG_SLOT_SEED, &[&parent_id, &le_bytes::<8>(slot as u128)]);
    let vdf_y_core = h_tag(constants::TAG_VDF_YCORE, &[&[1u8; 32]]);
    let vdf_y_edge = h_tag(constants::TAG_VDF_EDGE, &[&vdf_y_core]);
    Header {
        parent_id,
        slot,
        obex_version: OBEX_ALPHA_II_VERSION,
        seed_commit,
        vdf_y_core,
        vdf_y_edge,
        vdf_pi: vec![],
        vdf_ell: vec![],
        ticket_root: empty_root(),
        part_root: empty_root(),
        txroot_prev: empty_root(),
    }
}

#[test]
fn e2e_empty_slot_header_roundtrip_and_mismatch() {
    let parent = mk_parent();
    let s = parent.slot + 1;
    let parent_id_hdr = obex_header_id(&parent);
    let seed_commit = h_tag(constants::TAG_SLOT_SEED, &[&parent_id_hdr, &le_bytes::<8>(s as u128)]);
    let y_core = h_tag(constants::TAG_VDF_YCORE, &[&[2u8; 32]]);
    let y_edge = h_tag(constants::TAG_VDF_EDGE, &[&y_core]);

    let ticket_roots = EmptyTicketRoot;
    let part_roots = EmptyPartRoot;
    let tx_roots = EmptyTxRoot;
    let h = build_header(
        &parent,
        (seed_commit, y_core, y_edge, vec![], vec![]),
        &ticket_roots,
        &part_roots,
        &tx_roots,
        OBEX_ALPHA_II_VERSION,
    );

    let id = obex_header_id(&h);
    assert_eq!(id, obex_header_id(&h), "id stable");

    let beacon = BeaconOk;
    assert!(
        validate_header(
            &h, &parent, &beacon, &ticket_roots, &part_roots, &tx_roots, OBEX_ALPHA_II_VERSION
        )
        .is_ok()
    );

    // Flip part_root â†’ PartRootMismatch
    let mut bad = h.clone();
    bad.part_root[0] ^= 1;
    let err = validate_header(
        &bad, &parent, &beacon, &ticket_roots, &part_roots, &tx_roots, OBEX_ALPHA_II_VERSION,
    )
    .unwrap_err();
    assert!(matches!(err, ValidateErr::PartRootMismatch));
}




crates>obex_alpha_ii>tests>e2e_three_slots.rs
use obex_alpha_ii::{build_header, obex_header_id, validate_header, BeaconInputs, BeaconVerifier, Header, PartRootProvider, TicketRootProvider, TxRootProvider, OBEX_ALPHA_II_VERSION};
use obex_primitives::{constants, h_tag, le_bytes, Hash256, Pk32};

fn empty_root() -> Hash256 { h_tag(constants::TAG_MERKLE_EMPTY, &[]) }

struct BeaconOk;
impl BeaconVerifier for BeaconOk {
    fn verify(&self, i: &BeaconInputs<'_>) -> bool {
        let seed_expected = h_tag(constants::TAG_SLOT_SEED, &[i.parent_id, &le_bytes::<8>(i.slot as u128)]);
        seed_expected == *i.seed_commit && h_tag(constants::TAG_VDF_EDGE, &[i.vdf_y_core]) == *i.vdf_y_edge
    }
}

struct Providers<'a> { part_pks: &'a [Pk32], txids_by_slot: &'a [(u64, Vec<Hash256>)] }

impl PartRootProvider for Providers<'_> {
    fn compute_part_root(&self, _slot: u64) -> Hash256 {
        let leaves: Vec<Vec<u8>> = self.part_pks.iter().map(|pk| {
            let mut b = Vec::with_capacity(64);
            b.extend_from_slice(&h_tag(constants::TAG_PART_LEAF, &[]));
            b.extend_from_slice(pk);
            b
        }).collect();
        obex_primitives::merkle_root(&leaves)
    }
}
impl TicketRootProvider for Providers<'_> {
    fn compute_ticket_root(&self, slot: u64) -> Hash256 {
        // Create synthetic tickets from txids_by_slot
        let mut list = self.txids_by_slot.iter().find(|(s,_v)| *s == slot).map(|(_,v)| v.clone()).unwrap_or_default();
        list.sort();
        let leaves: Vec<Vec<u8>> = list.iter().map(|txid| {
            let mut payload = Vec::new();
            payload.extend_from_slice(&h_tag(constants::TAG_TXID_LEAF, &[]));
            payload.extend_from_slice(txid);
            payload
        }).collect();
        obex_primitives::merkle_root(&leaves)
    }
}
impl TxRootProvider for Providers<'_> {
    fn compute_txroot(&self, slot: u64) -> Hash256 {
        let mut list = self.txids_by_slot.iter().find(|(s,_v)| *s == slot).map(|(_,v)| v.clone()).unwrap_or_default();
        list.sort();
        let leaves: Vec<Vec<u8>> = list.iter().map(|txid| {
            let mut payload = Vec::new();
            payload.extend_from_slice(&h_tag(constants::TAG_TXID_LEAF, &[]));
            payload.extend_from_slice(txid);
            payload
        }).collect();
        obex_primitives::merkle_root(&leaves)
    }
}

fn mk_parent() -> Header {
    let parent_id = [0u8;32];
    let slot = 0u64;
    let seed_commit = h_tag(constants::TAG_SLOT_SEED, &[&parent_id, &le_bytes::<8>(slot as u128)]);
    let vdf_y_core = h_tag(constants::TAG_VDF_YCORE, &[&[1u8;32]]);
    let vdf_y_edge = h_tag(constants::TAG_VDF_EDGE, &[&vdf_y_core]);
    Header { parent_id, slot, obex_version: OBEX_ALPHA_II_VERSION, seed_commit, vdf_y_core, vdf_y_edge, vdf_pi: vec![], vdf_ell: vec![], ticket_root: empty_root(), part_root: empty_root(), txroot_prev: empty_root() }
}

#[test]
fn e2e_three_slots_freeze() {
    // Participation set for slots 1..=3 (static mock pks)
    let part_pks: Vec<Pk32> = vec![[1u8;32],[2u8;32],[3u8;32]];
    let providers = Providers { part_pks: &part_pks, txids_by_slot: &[] };
    let beacon = BeaconOk;

    let parent = mk_parent();
    // Build headers for slots 1..=3 with empty tx roots
    let mut headers = Vec::new();
    let mut h_prev = parent.clone();
    for s1 in 1..=3u64 {
        let seed_commit = h_tag(constants::TAG_SLOT_SEED, &[&obex_header_id(&h_prev), &le_bytes::<8>(s1 as u128)]);
        let y_core = h_tag(constants::TAG_VDF_YCORE, &[&[s1 as u8; 32]]);
        let y_edge = h_tag(constants::TAG_VDF_EDGE, &[&y_core]);
        let h = build_header(&h_prev, (seed_commit, y_core, y_edge, vec![], vec![]), &providers, &providers, &providers, OBEX_ALPHA_II_VERSION);
        assert!(validate_header(&h, &h_prev, &beacon, &providers, &providers, &providers, OBEX_ALPHA_II_VERSION).is_ok());
        headers.push(h.clone());
        h_prev = h;
    }

    // Freeze header IDs uniqueness across 3 slots
    let ids: Vec<Hash256> = headers.iter().map(obex_header_id).collect();
    assert!(ids[0] != ids[1] && ids[1] != ids[2] && ids[0] != ids[2]);
}




crates>obex_alpha_ii>tests>gating.rs
use obex_alpha_ii::*;
use obex_primitives::Hash256;

#[test]
fn header_validate_err_parent_link() {
    struct BeaconOk; impl BeaconVerifier for BeaconOk { fn verify(&self, _i: &BeaconInputs<'_>) -> bool { true } }
    struct Zero; impl TicketRootProvider for Zero { fn compute_ticket_root(&self, _s: u64)->Hash256{[0;32]} }
    impl PartRootProvider for Zero { fn compute_part_root(&self,_:u64)->Hash256{[0;32]} }
    impl TxRootProvider for Zero { fn compute_txroot(&self,_:u64)->Hash256{[0;32]} }

    let parent = Header{ parent_id:[9;32], slot:7, obex_version:OBEX_ALPHA_II_VERSION,
        seed_commit:[1;32], vdf_y_core:[2;32], vdf_y_edge:[3;32], vdf_pi:vec![], vdf_ell:vec![],
        ticket_root:[0;32], part_root:[0;32], txroot_prev:[0;32] };
    let providers=Zero; let beacon=BeaconOk;
    let mut h = build_header(&parent, ([4;32],[5;32],[6;32], vec![], vec![]), &providers,&providers,&providers, OBEX_ALPHA_II_VERSION);
    h.parent_id = [8;32];
    assert!(matches!(validate_header(&h,&parent,&beacon,&providers,&providers,&providers,OBEX_ALPHA_II_VERSION), Err(ValidateErr::BadParentLink)));
}




crates>obex_alpha_ii>tests>golden.rs
#![allow(unused)]
use obex_alpha_ii::{Header, serialize_header, deserialize_header, obex_header_id, OBEX_ALPHA_II_VERSION};
use hex::ToHex;

#[test]
fn header_golden_roundtrip() {
    let h = Header {
        parent_id: [1u8;32],
        slot: 42,
        obex_version: OBEX_ALPHA_II_VERSION,
        seed_commit: [2u8;32],
        vdf_y_core: [3u8;32],
        vdf_y_edge: [4u8;32],
        vdf_pi: vec![0xAA,0xBB],
        vdf_ell: vec![0xCC],
        ticket_root: [5u8;32],
        part_root: [6u8;32],
        txroot_prev: [7u8;32],
    };
    let bytes = serialize_header(&h);
    let h2 = deserialize_header(&bytes).expect("decode");
    assert_eq!(h2.slot, h.slot);
    assert_eq!(obex_header_id(&h2), obex_header_id(&h));
    // KAT: header id hex is stable given deterministic fields
    let id_hex = obex_header_id(&h).encode_hex::<String>();
    assert_eq!(id_hex, "ddb4398849e1938cdadae933065712f7548f1827779792fd2356b77390922098");
}



crates>obex_alpha_ii>tests>golden_header.rs
use obex_alpha_ii::{deserialize_header, obex_header_id, validate_header, BeaconInputs, BeaconVerifier, PartRootProvider, TicketRootProvider, TxRootProvider, OBEX_ALPHA_II_VERSION};
use obex_primitives::{constants, h_tag, le_bytes, Hash256};

struct BeaconOk;
impl BeaconVerifier for BeaconOk { fn verify(&self, _i: &BeaconInputs<'_>) -> bool { true } }
struct ZeroRoot;
impl TicketRootProvider for ZeroRoot { fn compute_ticket_root(&self, _slot: u64) -> Hash256 { [0u8;32] } }
impl PartRootProvider   for ZeroRoot { fn compute_part_root(&self, _slot: u64) -> Hash256 { [0u8;32] } }
impl TxRootProvider     for ZeroRoot { fn compute_txroot(&self, _slot: u64) -> Hash256 { [0u8;32] } }

#[test]
fn golden_header_accept_placeholder() {
    // Placeholder: use an empty header wire image for now; replace with committed golden file
    // once generated by the harness.
    let parent_id = [9u8; 32];
    let slot = 7u64;
    let seed_commit = h_tag(constants::TAG_SLOT_SEED, &[&parent_id, &le_bytes::<8>(slot as u128)]);
    let mut bytes = Vec::new();
    bytes.extend_from_slice(&parent_id);
    bytes.extend_from_slice(&le_bytes::<8>(u128::from(slot + 1)));
    bytes.extend_from_slice(&le_bytes::<4>(u128::from(OBEX_ALPHA_II_VERSION)));
    bytes.extend_from_slice(&seed_commit);
    bytes.extend_from_slice(&[2u8;32]); // vdf_y_core
    bytes.extend_from_slice(&[3u8;32]); // vdf_y_edge
    bytes.extend_from_slice(&le_bytes::<4>(0));
    bytes.extend_from_slice(&[]);
    bytes.extend_from_slice(&le_bytes::<4>(0));
    bytes.extend_from_slice(&[]);
    bytes.extend_from_slice(&[0u8;32]); // ticket_root
    bytes.extend_from_slice(&[0u8;32]); // part_root
    bytes.extend_from_slice(&[0u8;32]); // txroot_prev

    let h = deserialize_header(&bytes).expect("decode");
    let _id = obex_header_id(&h);
    let z = ZeroRoot; let b = BeaconOk;
    assert!(validate_header(&h, &h.clone(), &b, &z, &z, &z, OBEX_ALPHA_II_VERSION).is_err());
}




crates>obex_alpha_ii>tests>golden_header_bytes.rs
use std::fs;
use std::path::Path;

use hex::ToHex;
use obex_alpha_ii::{deserialize_header, obex_header_id};

fn golden_dir() -> std::path::PathBuf {
    Path::new(env!("CARGO_MANIFEST_DIR")).join("tests").join("golden")
}

#[test]
fn golden_header_parent_and_child_roundtrip() {
    let dir = golden_dir();
    for name in ["header_v2_parent.bin", "header_v2_slot1.bin"] {
        let path = dir.join(name);
        let bytes = fs::read(&path).expect("read golden header");
        let h = deserialize_header(&bytes).expect("decode header");
        let enc = obex_alpha_ii::serialize_header(&h);
        assert_eq!(enc, bytes, "wire bytes stable for {name}");
    }
}

#[test]
fn golden_header_child_id_matches_hex() {
    let dir = golden_dir();
    let bytes = fs::read(dir.join("header_v2_slot1.bin")).expect("read child");
    let h = deserialize_header(&bytes).expect("decode child");
    let id_hex = obex_header_id(&h).encode_hex::<String>();
    let exp_hex = fs::read_to_string(dir.join("header_v2_slot1.id.hex")).expect("read id hex");
    assert_eq!(id_hex, exp_hex);
}

#[test]
fn golden_header_flipbit_changes_id_or_decode() {
    let dir = golden_dir();
    let bytes = fs::read(dir.join("header_v2_slot1.bin")).expect("read child");
    for i in [0usize, 8, 12, 32, 64, bytes.len() - 1] {
        let mut b = bytes.clone();
        b[i] ^= 1;
        if let Ok(h2) = obex_alpha_ii::deserialize_header(&b) {
            let id1 = obex_header_id(&obex_alpha_ii::deserialize_header(&bytes).unwrap());
            let id2 = obex_header_id(&h2);
            assert_ne!(id1, id2, "flip bit should alter header id");
        }
    }
}




crates>obex_alpha_ii>tests>kat_dump.rs
use obex_alpha_ii::*;
use hex::ToHex;

#[test]
fn dump_header_id_hex() {
    let h = Header {
        parent_id: [1u8;32],
        slot: 42,
        obex_version: OBEX_ALPHA_II_VERSION,
        seed_commit: [2u8;32],
        vdf_y_core: [3u8;32],
        vdf_y_edge: [4u8;32],
        vdf_pi: vec![0xAA,0xBB],
        vdf_ell: vec![0xCC],
        ticket_root: [5u8;32],
        part_root: [6u8;32],
        txroot_prev: [7u8;32],
    };
    let id_hex = obex_header_id(&h).encode_hex::<String>();
    println!("HEADER_ID_HEX:{id_hex}");
}




crates>obex_alpha_ii>tests>golden>header_v2_parent.bin
                                           ‰ü‹;íd×ÔB\ùóùœ€´ÉØElÎï†uŒZÜgêQß7m‚Q˜¥¶hù@
	/õ¿Ó3“„J“€ËÖa |a„OO¢6­¾§Œh"4½WïUW2mñÉ»ç}¨        +%J¬Ô<SwÈû#mî`<åí>q2³í*;¶"…~+%J¬Ô<SwÈû#mî`<åí>q2³í*;¶"…~+%J¬Ô<SwÈû#mî`<åí>q2³í*;¶"…~

crates>obex_alpha_ii>tests>golden>header_v2_slot1.bin
q›‚‡Ìäñ^9\n2=$2Ap1‹g­@ñ3ï3êÍQ†»          =]÷niq9k[?»ÜN êG’¼ra€t®­#HV^)øp(èÌ3Ô§UMM<ÉÓV§øö+ûÂ)YÁyAÛ¹O¸Â¸¢íûÌ¼j±Ví¿»IDxÿ;€NwÇ
2|        +%J¬Ô<SwÈû#mî`<åí>q2³í*;¶"…~+%J¬Ô<SwÈû#mî`<åí>q2³í*;¶"…~+%J¬Ô<SwÈû#mî`<åí>q2³í*;¶"…~

crates>obex_alpha_ii>tests>golden>header_v2_slot1.id.hex
18684261ff6a1b84b94772ee1e3d3f12d6031eea2ac825fa32437709f2a7ca67

crates>obex_alpha_iii>Cargo.toml
[package]
name = "obex_alpha_iii"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "Obex Î± III â€” Deterministic Admission (final within slot)"
repository = "https://github.com/obex-labs/obex-alpha"
readme = "../../README.md"
keywords = ["obex","consensus","admission","transactions","merkle"]
categories = ["cryptography","algorithms","data-structures"]

[dependencies]
obex_primitives = { path = "../obex_primitives" }
ed25519-dalek = { version = "2", default-features = true }
thiserror = "2.0"


[dev-dependencies]
hex = "0.4"




crates>obex_alpha_iii>src>lib.rs
#![forbid(unsafe_code)]
#![deny(
    warnings,
    clippy::all,
    clippy::pedantic,
    clippy::nursery,
    clippy::cargo
)]
#![allow(
    clippy::module_name_repetitions,
    clippy::missing_errors_doc,
    clippy::missing_panics_doc,
    clippy::result_large_err
)]

//! obex.Î± III â€” Deterministic Admission (final within slot)
//!
//! Implements admission checks, fee rule, canonical encodings, `TicketRecord`, and per-slot
//! Merkle root, per `obex.alpha III.txt`. Uses Ed25519 for signatures.

use ed25519_dalek::{Signature, VerifyingKey};
use obex_primitives::{constants, h_tag, le_bytes, merkle_root, Hash256, Pk32, Sig64};

pub type Sig = Sig64;

pub const MIN_TX_UOBX: u128 = 10;
pub const FLAT_SWITCH_UOBX: u128 = 1_000;
pub const FLAT_FEE_UOBX: u128 = 10;
pub const PCT_DEN: u128 = 100;

#[inline]
#[must_use]
pub fn fee_int_uobx(amount_u: u128) -> u128 {
    assert!(amount_u >= MIN_TX_UOBX);
    if amount_u <= FLAT_SWITCH_UOBX { FLAT_FEE_UOBX } else { amount_u.div_ceil(PCT_DEN) }
}

#[derive(Clone, Default, Debug, PartialEq, Eq)]
pub struct AccessList {
    pub read_accounts: Vec<Pk32>,
    pub write_accounts: Vec<Pk32>,
}

fn sort_dedup(mut v: Vec<Pk32>) -> Vec<Pk32> { v.sort_unstable(); v.dedup(); v }

#[must_use]
pub fn encode_access(a: &AccessList) -> Vec<u8> {
    let r = sort_dedup(a.read_accounts.clone());
    let w = sort_dedup(a.write_accounts.clone());
    let mut out = Vec::new();
    out.extend_from_slice(&h_tag(constants::TAG_TX_ACCESS, &[]));
    out.extend_from_slice(&le_bytes::<4>(r.len() as u128));
    for pk in &r { out.extend_from_slice(pk); }
    out.extend_from_slice(&le_bytes::<4>(w.len() as u128));
    for pk in &w { out.extend_from_slice(pk); }
    out
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct TxBodyV1 {
    pub sender: Pk32,
    pub recipient: Pk32,
    pub nonce: u64,
    pub amount_u: u128,
    pub fee_u: u128,
    pub s_bind: u64,
    pub y_bind: Hash256,
    pub access: AccessList,
    pub memo: Vec<u8>,
}

#[must_use]
pub fn canonical_tx_bytes(tx: &TxBodyV1) -> Vec<u8> {
    let mut out = Vec::new();
    out.extend_from_slice(&h_tag(constants::TAG_TX_BODY_V1, &[]));
    out.extend_from_slice(&tx.sender);
    out.extend_from_slice(&tx.recipient);
    out.extend_from_slice(&le_bytes::<8>(u128::from(tx.nonce)));
    out.extend_from_slice(&le_bytes::<16>(tx.amount_u));
    out.extend_from_slice(&le_bytes::<16>(tx.fee_u));
    out.extend_from_slice(&le_bytes::<8>(u128::from(tx.s_bind)));
    out.extend_from_slice(&tx.y_bind);
    out.extend_from_slice(&encode_access(&tx.access));
    out.extend_from_slice(&le_bytes::<4>(tx.memo.len() as u128));
    out.extend_from_slice(&tx.memo);
    out
}

#[must_use]
pub fn txid(tx: &TxBodyV1) -> Hash256 { h_tag(constants::TAG_TX_ID, &[&canonical_tx_bytes(tx)]) }

#[must_use]
pub fn tx_commit(tx: &TxBodyV1) -> Hash256 { h_tag(constants::TAG_TX_COMMIT, &[&canonical_tx_bytes(tx)]) }

#[must_use]
fn verify_sig(pk: &Pk32, msg: &[u8], sig: &Sig) -> bool {
    match (VerifyingKey::from_bytes(pk), Signature::from_slice(sig)) {
        (Ok(vk), Ok(sig_d)) => vk.verify_strict(msg, &sig_d).is_ok(),
        _ => false,
    }
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub struct TicketRecord {
    pub ticket_id: Hash256,
    pub txid: Hash256,
    pub sender: Pk32,
    pub nonce: u64,
    pub amount_u: u128,
    pub fee_u: u128,
    pub s_admit: u64,
    pub s_exec: u64,
    pub commit_hash: Hash256,
}

#[must_use]
pub fn enc_ticket_leaf(t: &TicketRecord) -> Vec<u8> {
    let mut out = Vec::new();
    out.extend_from_slice(&h_tag(constants::TAG_TICKET_LEAF, &[]));
    out.extend_from_slice(&t.ticket_id);
    out.extend_from_slice(&t.txid);
    out.extend_from_slice(&t.sender);
    out.extend_from_slice(&le_bytes::<8>(u128::from(t.nonce)));
    out.extend_from_slice(&le_bytes::<16>(t.amount_u));
    out.extend_from_slice(&le_bytes::<16>(t.fee_u));
    out.extend_from_slice(&le_bytes::<8>(u128::from(t.s_admit)));
    out.extend_from_slice(&le_bytes::<8>(u128::from(t.s_exec)));
    out.extend_from_slice(&t.commit_hash);
    out
}

#[derive(Default, Clone, Debug, PartialEq, Eq)]
pub struct AlphaIIIState {
    pub spendable_u: std::collections::BTreeMap<Pk32, u128>,
    pub reserved_u: std::collections::BTreeMap<Pk32, u128>,
    pub next_nonce: std::collections::BTreeMap<Pk32, u64>,
    pub admitted_by_slot: std::collections::BTreeMap<u64, Vec<TicketRecord>>,
    pub tickets_by_txid: std::collections::BTreeMap<Hash256, TicketRecord>,
}

impl AlphaIIIState {
    #[must_use] pub fn spendable_of(&self, pk: &Pk32) -> u128 { *self.spendable_u.get(pk).unwrap_or(&0) }
    #[must_use] pub fn reserved_of(&self,  pk: &Pk32) -> u128 { *self.reserved_u .get(pk).unwrap_or(&0) }
    #[must_use] pub fn nonce_of(&self,     pk: &Pk32) -> u64  { *self.next_nonce .get(pk).unwrap_or(&0) }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum AdmitErr { BadSig, WrongSlot, WrongBeacon, NonceMismatch, BelowMinAmount, FeeMismatch, InsufficientFunds }

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum AdmitResult { Finalized(TicketRecord), Rejected(AdmitErr) }

#[must_use]
pub fn admit_single(tx: &TxBodyV1, sig: &Sig, s_now: u64, y_prev: &Hash256, st: &mut AlphaIIIState) -> AdmitResult {
    let msg = h_tag(constants::TAG_TX_SIG, &[&canonical_tx_bytes(tx)]);
    if !verify_sig(&tx.sender, &msg, sig) { return AdmitResult::Rejected(AdmitErr::BadSig); }
    if tx.s_bind != s_now { return AdmitResult::Rejected(AdmitErr::WrongSlot); }
    if tx.y_bind != *y_prev { return AdmitResult::Rejected(AdmitErr::WrongBeacon); }
    if tx.nonce != st.nonce_of(&tx.sender) { return AdmitResult::Rejected(AdmitErr::NonceMismatch); }
    if tx.amount_u < MIN_TX_UOBX { return AdmitResult::Rejected(AdmitErr::BelowMinAmount); }
    if tx.fee_u != fee_int_uobx(tx.amount_u) { return AdmitResult::Rejected(AdmitErr::FeeMismatch); }
    let total = tx.amount_u.saturating_add(tx.fee_u);
    if st.spendable_of(&tx.sender) < total { return AdmitResult::Rejected(AdmitErr::InsufficientFunds); }

    *st.spendable_u.entry(tx.sender).or_insert(0) -= total;
    *st.reserved_u .entry(tx.sender).or_insert(0) += total;
    *st.next_nonce.entry(tx.sender).or_insert(0)  += 1;

    let xid = txid(tx);
    let rec = TicketRecord {
        ticket_id: h_tag(constants::TAG_TICKET_ID, &[&xid, &le_bytes::<8>(u128::from(s_now))]),
        txid: xid,
        sender: tx.sender,
        nonce: tx.nonce,
        amount_u: tx.amount_u,
        fee_u: tx.fee_u,
        s_admit: s_now,
        s_exec: s_now,
        commit_hash: tx_commit(tx),
    };
    st.admitted_by_slot.entry(s_now).or_default().push(rec.clone());
    st.tickets_by_txid.insert(rec.txid, rec.clone());
    AdmitResult::Finalized(rec)
}

#[must_use]
pub fn admit_slot_canonical(
    s_now: u64,
    y_prev: &Hash256,
    candidates_sorted: &[(TxBodyV1, Sig)],
    st: &mut AlphaIIIState,
) -> Vec<TicketRecord> {
    let mut out = Vec::new();
    for (tx, sig) in candidates_sorted {
        match admit_single(tx, sig, s_now, y_prev, st) {
            AdmitResult::Finalized(rec) => out.push(rec),
            AdmitResult::Rejected(_) => {}
        }
    }
    out
}

#[must_use]
pub fn build_ticket_root_for_slot(s: u64, st: &AlphaIIIState) -> (Vec<Vec<u8>>, Hash256) {
    let mut list = st.admitted_by_slot.get(&s).cloned().unwrap_or_default();
    list.sort_by(|a, b| a.txid.cmp(&b.txid));
    let leaves: Vec<Vec<u8>> = list.iter().map(enc_ticket_leaf).collect();
    let root = merkle_root(&leaves);
    (leaves, root)
}

#[cfg(test)]
mod tests {
    use super::*;

    fn pk(val: u8) -> Pk32 { [val; 32] }

    #[test]
    fn fee_rule_matches_branches() {
        assert_eq!(fee_int_uobx(10), FLAT_FEE_UOBX);
        assert_eq!(fee_int_uobx(1_000), FLAT_FEE_UOBX);
        assert_eq!(fee_int_uobx(1_001), 11);
    }

    #[test]
    fn empty_slot_merkle_root_is_empty_tag() {
        let st = AlphaIIIState::default();
    let (_leaves, root) = build_ticket_root_for_slot(1, &st);
    assert_eq!(root, h_tag(constants::TAG_MERKLE_EMPTY, &[]));
    }

    #[test]
    fn admit_updates_state_and_ticket_root() {
        let mut st = AlphaIIIState::default();
        st.spendable_u.insert(pk(1), 10_000);
        let tx = TxBodyV1 {
            sender: pk(1),
            recipient: pk(2),
            nonce: 0,
            amount_u: 2_000,
            fee_u: fee_int_uobx(2_000),
            s_bind: 5,
            y_bind: [7u8; 32],
            access: AccessList::default(),
            memo: vec![],
        };
        // Use an invalid signature to trigger BadSig quickly (we don't carry private keys here)
        let sig = [0u8; 64];
        let res = admit_single(&tx, &sig, 5, &tx.y_bind, &mut st);
        match res {
            AdmitResult::Rejected(_) | AdmitResult::Finalized(_) => {}
        }
        let (_leaves, _root) = build_ticket_root_for_slot(5, &st);
    }
}




crates>obex_alpha_iii>tests>gating.rs
use obex_alpha_iii::*;
use obex_primitives::{constants, h_tag, Pk32};
use ed25519_dalek::{SigningKey, Signer, VerifyingKey};

const fn pk(val: u8) -> Pk32 { [val; 32] }

#[test]
fn reject_fee_mismatch() {
    // Generate a valid signature for the transaction to reach the fee check
    let sk = SigningKey::from_bytes(&[1u8; 32]);
    let vk: VerifyingKey = (&sk).into();
    let sender_pk: Pk32 = vk.to_bytes();
    let tx = TxBodyV1{ sender: sender_pk, recipient: pk(2), nonce:0, amount_u: 2_000, fee_u: 1, s_bind: 5, y_bind: [7u8;32], access: AccessList::default(), memo: vec![]};
    let msg = h_tag(constants::TAG_TX_SIG, &[&canonical_tx_bytes(&tx)]);
    let sig = sk.sign(&msg).to_bytes();
    let mut st=AlphaIIIState::default();
    match admit_single(&tx, &sig, 5, &tx.y_bind, &mut st) { AdmitResult::Rejected(AdmitErr::FeeMismatch)=>{}, _=> panic!("expected fee mismatch") }
}

#[test]
fn empty_slot_ticket_root_matches_empty_tag() {
    let st=AlphaIIIState::default(); let (_leaves,root)=build_ticket_root_for_slot(1,&st);
    assert_eq!(root, obex_primitives::h_tag(obex_primitives::constants::TAG_MERKLE_EMPTY, &[]));
}



crates>obex_alpha_iii>tests>golden_roots.rs
use obex_alpha_iii::*;
use obex_primitives::{constants, h_tag, merkle_root, Pk32};
use hex::ToHex;

const fn pk(val: u8) -> Pk32 { [val; 32] }

#[test]
fn ticket_and_tx_roots_fixed_hex() {
    let y_prev = [7u8; 32];
    let s_now = 5u64;
    let tx1 = TxBodyV1 { sender: pk(1), recipient: pk(2), nonce: 0, amount_u: 2_000, fee_u: fee_int_uobx(2_000), s_bind: s_now, y_bind: y_prev, access: AccessList::default(), memo: vec![] };
    let tx2 = TxBodyV1 { sender: pk(3), recipient: pk(4), nonce: 0, amount_u: 1_234, fee_u: fee_int_uobx(1_234), s_bind: s_now, y_bind: y_prev, access: AccessList::default(), memo: vec![0xAA, 0xBB] };

    let rec1 = TicketRecord { ticket_id: h_tag(constants::TAG_TICKET_ID, &[&txid(&tx1), &obex_primitives::le_bytes::<8>(u128::from(s_now))]), txid: txid(&tx1), sender: tx1.sender, nonce: tx1.nonce, amount_u: tx1.amount_u, fee_u: tx1.fee_u, s_admit: s_now, s_exec: s_now, commit_hash: tx_commit(&tx1) };
    let rec2 = TicketRecord { ticket_id: h_tag(constants::TAG_TICKET_ID, &[&txid(&tx2), &obex_primitives::le_bytes::<8>(u128::from(s_now))]), txid: txid(&tx2), sender: tx2.sender, nonce: tx2.nonce, amount_u: tx2.amount_u, fee_u: tx2.fee_u, s_admit: s_now, s_exec: s_now, commit_hash: tx_commit(&tx2) };

    let mut list = vec![rec1.clone(), rec2.clone()];
    list.sort_by(|a,b| a.txid.cmp(&b.txid));
    let leaves: Vec<Vec<u8>> = list.iter().map(enc_ticket_leaf).collect();
    let ticket_root = merkle_root(&leaves).encode_hex::<String>();
    assert_eq!(ticket_root, "567052422067e8d59cbbcfade725a0c3e21d77e947fd465908a6425fb998c95f");

    let txids = [rec1.txid, rec2.txid];
    let leaves_tx: Vec<Vec<u8>> = txids.iter().map(|xid| { let mut v = Vec::with_capacity(64); v.extend_from_slice(&h_tag(constants::TAG_TXID_LEAF, &[])); v.extend_from_slice(xid); v }).collect();
    let txroot = merkle_root(&leaves_tx).encode_hex::<String>();
    assert_eq!(txroot, "217d4936f78adf09a87c9a25171c280395fa185190308c4142a314266854433f");
}




crates>obex_alpha_iii>tests>kat_dump.rs
use obex_alpha_iii::*;
use obex_primitives::{constants, h_tag, merkle_root, Pk32};
use hex::ToHex;

const fn pk(val: u8) -> Pk32 { [val; 32] }

#[test]
fn dump_ticket_and_tx_roots_hex() {
    // Two simple txs for the same slot/bind
    let y_prev = [7u8; 32];
    let s_now = 5u64;
    let tx1 = TxBodyV1 { sender: pk(1), recipient: pk(2), nonce: 0, amount_u: 2_000, fee_u: fee_int_uobx(2_000), s_bind: s_now, y_bind: y_prev, access: AccessList::default(), memo: vec![] };
    let tx2 = TxBodyV1 { sender: pk(3), recipient: pk(4), nonce: 0, amount_u: 1_234, fee_u: fee_int_uobx(1_234), s_bind: s_now, y_bind: y_prev, access: AccessList::default(), memo: vec![0xAA, 0xBB] };

    // Build TicketRecords deterministically as admit_single would for Finalized cases
    let rec1 = TicketRecord { ticket_id: h_tag(constants::TAG_TICKET_ID, &[&txid(&tx1), &obex_primitives::le_bytes::<8>(u128::from(s_now))]), txid: txid(&tx1), sender: tx1.sender, nonce: tx1.nonce, amount_u: tx1.amount_u, fee_u: tx1.fee_u, s_admit: s_now, s_exec: s_now, commit_hash: tx_commit(&tx1) };
    let rec2 = TicketRecord { ticket_id: h_tag(constants::TAG_TICKET_ID, &[&txid(&tx2), &obex_primitives::le_bytes::<8>(u128::from(s_now))]), txid: txid(&tx2), sender: tx2.sender, nonce: tx2.nonce, amount_u: tx2.amount_u, fee_u: tx2.fee_u, s_admit: s_now, s_exec: s_now, commit_hash: tx_commit(&tx2) };

    // ticket_root: sort by txid ascending
    let mut list = vec![rec1.clone(), rec2.clone()];
    list.sort_by(|a,b| a.txid.cmp(&b.txid));
    let leaves: Vec<Vec<u8>> = list.iter().map(enc_ticket_leaf).collect();
    let ticket_root = merkle_root(&leaves);
    println!("TICKET_ROOT:{}", ticket_root.encode_hex::<String>());

    // txroot: leaves = tag || txid for executed (previous slot); here we just use tx ids
    let txids = [rec1.txid, rec2.txid];
    let leaves_tx: Vec<Vec<u8>> = txids.iter().map(|xid| { let mut v = Vec::with_capacity(64); v.extend_from_slice(&h_tag(constants::TAG_TXID_LEAF, &[])); v.extend_from_slice(xid); v }).collect();
    let txroot = merkle_root(&leaves_tx);
    println!("TXROOT:{}", txroot.encode_hex::<String>());
}




crates>obex_alpha_t>Cargo.toml
[package]
name = "obex_alpha_t"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "Obex Î± T â€” Tokenomics (Emission, Escrow, DRP)"
repository = "https://github.com/obex-labs/obex-alpha"
readme = "../../README.md"
keywords = ["obex","consensus","tokenomics","fees"]
categories = ["cryptography","algorithms","data-structures"]

[dependencies]
obex_primitives = { path = "../obex_primitives" }
thiserror = "2.0"
primitive-types = "0.12"

[dev-dependencies]
hex = "0.4"




crates>obex_alpha_t>src>lib.rs
#![forbid(unsafe_code)]
#![deny(
    warnings,
    clippy::all,
    clippy::pedantic,
    clippy::nursery,
    clippy::cargo
)]
#![allow(
    clippy::module_name_repetitions,
    clippy::missing_errors_doc,
    clippy::missing_panics_doc,
    clippy::result_large_err
)]

//! obex.Î± T â€” Tokenomics (Deterministic Emission, Fees, and Validator Rewards)
//! Implements emission schedule, fee escrow with epoch-stable splits (NLB), and DRP distribution.

use std::sync::LazyLock as Lazy;
use obex_primitives::{constants, h_tag, le_bytes, u64_from_le, Hash256};
use primitive_types::U256;
use thiserror::Error;

pub const UOBX_PER_OBX: u128 = 100_000_000;
pub const TOTAL_SUPPLY_OBX: u128 = 1_000_000;
pub const TOTAL_SUPPLY_UOBX: u128 = TOTAL_SUPPLY_OBX * UOBX_PER_OBX;

pub const SLOT_MS: u64 = 100;
pub const SLOTS_PER_SEC: u64 = 1_000 / SLOT_MS;
pub const PROTOCOL_YEAR_SEC: u64 = 365 * 86_400;
pub const SLOTS_PER_YEAR: u64 = PROTOCOL_YEAR_SEC * SLOTS_PER_SEC;

pub const YEARS_PER_HALVING: u64 = 5;
pub const SLOTS_PER_HALVING: u128 = (SLOTS_PER_YEAR as u128) * (YEARS_PER_HALVING as u128);
pub const HALVING_COUNT: u32 = 20;
pub const LAST_EMISSION_SLOT: u128 = (SLOTS_PER_YEAR as u128) * 100;

#[inline] fn pow2_u256(n: u32) -> U256 { U256::from(1u8) << n }

static TWO_POW_N_MINUS1: Lazy<U256> = Lazy::new(|| pow2_u256(HALVING_COUNT - 1));
static TWO_POW_N:        Lazy<U256> = Lazy::new(|| pow2_u256(HALVING_COUNT));
static R0_NUM: Lazy<U256> = Lazy::new(|| U256::from(TOTAL_SUPPLY_UOBX) * *TWO_POW_N_MINUS1);
static R0_DEN: Lazy<U256> = Lazy::new(|| U256::from(SLOTS_PER_HALVING) * (*TWO_POW_N - U256::from(1u8)));

#[derive(Clone, Default, Debug, PartialEq, Eq)]
pub struct EmissionState { pub total_emitted_u: u128, pub acc_num: U256 }

#[inline]
#[allow(clippy::cast_possible_truncation)]
const fn period_index(slot_1based: u128) -> u32 {
    // Checked conversion: safe under consensus bounds (â‰¤ LAST_EMISSION_SLOT).
    let periods = (slot_1based - 1) / SLOTS_PER_HALVING;
    assert!(periods <= (u32::MAX as u128), "period index overflow");
    periods as u32
}
#[inline] fn reward_den_for_period(p: u32) -> U256 { *R0_DEN * pow2_u256(p) }

pub fn on_slot_emission(st: &mut EmissionState, slot_1based: u128, mut credit_emission: impl FnMut(u128)) {
    if slot_1based == 0 || slot_1based > LAST_EMISSION_SLOT { return; }
    let p = period_index(slot_1based);
    let den = reward_den_for_period(p);
    st.acc_num += *R0_NUM;
    let payout_u256 = st.acc_num / den;
    if payout_u256 > U256::zero() {
        let payout = payout_u256.as_u128();
        let remaining = TOTAL_SUPPLY_UOBX - st.total_emitted_u;
        let pay = payout.min(remaining);
        if pay > 0 {
            credit_emission(pay);
            st.total_emitted_u = st.total_emitted_u.saturating_add(pay);
            st.acc_num -= U256::from(pay) * den;
        }
    }
    if slot_1based == LAST_EMISSION_SLOT { assert!(st.total_emitted_u == TOTAL_SUPPLY_UOBX); }
}

pub const MIN_TRANSFER_U: u128 = 10;
pub const FLAT_SWITCH_U: u128 = 1_000;
pub const FLAT_FEE_U: u128 = 10;

#[inline]
#[must_use]
pub fn fee_int(amount_u: u128) -> u128 {
    assert!(amount_u >= MIN_TRANSFER_U);
    if amount_u <= FLAT_SWITCH_U { FLAT_FEE_U } else { amount_u.div_ceil(100) }
}

pub const NLB_EPOCH_SLOTS: u64 = 10_000;

#[derive(Clone, Debug, PartialEq, Eq, Default)]
pub struct NlbEpochState {
    pub epoch_index: u64,
    pub start_slot: u64,
    pub eff_supply_snapshot_u: u128,
    pub v_pct: u8,
    pub t_pct: u8,
    pub b_pct: u8,
}

#[derive(Clone, Default, Debug, PartialEq, Eq)]
pub struct FeeSplitState {
    pub acc_v_num: u128,
    pub acc_t_num: u128,
    pub acc_b_num: u128,
    pub fee_escrow_u: u128,
    pub total_burned_u: u128,
    pub nlb: NlbEpochState,
}

const TH_500K_OBX: u128 = 500_000 * UOBX_PER_OBX;
const TH_400K_OBX: u128 = 400_000 * UOBX_PER_OBX;
const TH_300K_OBX: u128 = 300_000 * UOBX_PER_OBX;
const TH_200K_OBX: u128 = 200_000 * UOBX_PER_OBX;

const BASE_TREASURY_PCT: u8 = 40;
const INITIAL_BURN_PCT: u8 = 20;
const BASE_VERIFIER_PCT: u8 = 40;
const BURN_FLOOR_PCT: u8 = 1;

#[inline]
const fn burn_percent(eff_Î¼: u128) -> u8 {
    if eff_Î¼ >= TH_500K_OBX { 20 }
    else if eff_Î¼ >= TH_400K_OBX { 15 }
    else if eff_Î¼ >= TH_300K_OBX { 10 }
    else if eff_Î¼ >= TH_200K_OBX { 5 }
    else { BURN_FLOOR_PCT }
}

#[inline]
fn compute_splits(eff_Î¼: u128) -> (u8, u8, u8) {
    let b = burn_percent(eff_Î¼);
    let redirect = INITIAL_BURN_PCT.saturating_sub(b);
    let v = BASE_VERIFIER_PCT.saturating_add(redirect);
    let t = BASE_TREASURY_PCT;
    debug_assert!((u16::from(v) + u16::from(t) + u16::from(b)) == 100);
    (v, t, b)
}

#[inline]
const fn epoch_index(slot: u64) -> u64 { slot / NLB_EPOCH_SLOTS }

pub fn nlb_roll_epoch_if_needed(slot: u64, fs: &mut FeeSplitState) {
    let idx = epoch_index(slot);
    if idx == fs.nlb.epoch_index { return; }
    fs.nlb.epoch_index = idx;
    fs.nlb.start_slot = idx * NLB_EPOCH_SLOTS;
    let eff_u = TOTAL_SUPPLY_UOBX.saturating_sub(fs.total_burned_u);
    fs.nlb.eff_supply_snapshot_u = eff_u;
    let (v, t, b) = compute_splits(eff_u);
    fs.nlb.v_pct = v; fs.nlb.t_pct = t; fs.nlb.b_pct = b;
}

const DEN_10K: u128 = 10_000; // Constants before statements per clippy

pub fn route_fee_with_nlb(
    fs: &mut FeeSplitState,
    fee_num: u128, fee_den: u128,
    mut credit_verifier: impl FnMut(u128),
    mut credit_treasury: impl FnMut(u128),
    mut burn: impl FnMut(u128),
) {
    let fee_num_over_100 = if fee_den == 1 { fee_num.saturating_mul(100) } else { fee_num };
    let add_v = fee_num_over_100.saturating_mul(u128::from(fs.nlb.v_pct));
    let add_t = fee_num_over_100.saturating_mul(u128::from(fs.nlb.t_pct));
    let add_b = fee_num_over_100.saturating_mul(u128::from(fs.nlb.b_pct));
    fs.acc_v_num = fs.acc_v_num.saturating_add(add_v);
    fs.acc_t_num = fs.acc_t_num.saturating_add(add_t);
    fs.acc_b_num = fs.acc_b_num.saturating_add(add_b);

    let mut rel_v = fs.acc_v_num / DEN_10K;
    let mut rel_t = fs.acc_t_num / DEN_10K;
    let mut rel_b = fs.acc_b_num / DEN_10K;

    let total_rel = rel_v.saturating_add(rel_t).saturating_add(rel_b);
    if total_rel > fs.fee_escrow_u {
        let mut deficit = total_rel - fs.fee_escrow_u;
        let reduce = |x: &mut u128, d: &mut u128| { let cut = (*x).min(*d); *x -= cut; *d -= cut; };
        reduce(&mut rel_b, &mut deficit);
        reduce(&mut rel_t, &mut deficit);
        reduce(&mut rel_v, &mut deficit);
    }

    if rel_v > 0 { credit_verifier(rel_v); fs.fee_escrow_u -= rel_v; fs.acc_v_num %= DEN_10K; }
    if rel_t > 0 { credit_treasury(rel_t); fs.fee_escrow_u -= rel_t; fs.acc_t_num %= DEN_10K; }
    if rel_b > 0 { burn(rel_b);            fs.fee_escrow_u -= rel_b; fs.acc_b_num %= DEN_10K; fs.total_burned_u = fs.total_burned_u.saturating_add(rel_b); }
}

#[allow(clippy::too_many_arguments)]
pub fn process_transfer(
    slot: u64,
    sender_balance_Î¼: u128,
    amount_Î¼: u128,
    fs: &mut FeeSplitState,
    mut debit_sender: impl FnMut(u128),
    mut credit_recipient: impl FnMut(u128),
    mut escrow_credit: impl FnMut(u128),
    credit_verifier: impl FnMut(u128),
    credit_treasury: impl FnMut(u128),
    burn: impl FnMut(u128),
) -> (u128, u128) {
    assert!(amount_Î¼ >= MIN_TRANSFER_U);
    nlb_roll_epoch_if_needed(slot, fs);
    let (fee_num, fee_den) = if amount_Î¼ <= FLAT_SWITCH_U { (FLAT_FEE_U, 1) } else { (amount_Î¼, 100) };
    let fee_Î¼ = fee_num.div_ceil(fee_den);
    let total_debit = amount_Î¼.saturating_add(fee_Î¼);
    assert!(sender_balance_Î¼ >= total_debit);
    debit_sender(total_debit);
    credit_recipient(amount_Î¼);
    fs.fee_escrow_u = fs.fee_escrow_u.saturating_add(fee_Î¼);
    escrow_credit(fee_Î¼);
    route_fee_with_nlb(fs, fee_num, fee_den, credit_verifier, credit_treasury, burn);
    (total_debit, fee_Î¼)
}

#[inline]
fn ctr_draw(y: &Hash256, s: u64, t: u32) -> Hash256 { h_tag(constants::TAG_REWARD_DRAW, &[y, &le_bytes::<8>(u128::from(s)), &le_bytes::<4>(u128::from(t))]) }

// Items before statements per clippy
use std::collections::BTreeSet;

#[must_use]
pub fn pick_k_unique_indices(y_edge_s: &Hash256, slot: u64, set_len: usize, winners_k: usize) -> Vec<usize> {
    if set_len == 0 || winners_k == 0 { return vec![]; }
    let mut out = Vec::with_capacity(winners_k);
    let mut seen = BTreeSet::new();
    let mut t: u32 = 0;
    while out.len() < winners_k {
        let h = ctr_draw(y_edge_s, slot, t);
        let idx = usize::try_from(u64_from_le(&h[..8]) % (set_len as u64)).unwrap_or(usize::MAX);
        if seen.insert(idx) { out.push(idx); }
        t = t.wrapping_add(1);
    }
    out
}

#[inline] fn reward_rank(y: &Hash256, pk: &Hash256) -> Hash256 { h_tag(constants::TAG_REWARD_RANK, &[y, pk]) }

pub const DRP_BASELINE_PCT: u8 = 20;
pub const DRP_K_WINNERS: usize = 16;

#[allow(clippy::too_many_arguments)]
pub fn distribute_drp_for_slot(
    s: u64,
    y_edge_s: &Hash256,
    part_set_sorted: &[Hash256],
    mut read_pool_balance: impl FnMut() -> u128,
    mut debit_pool: impl FnMut(u128),
    mut credit_pk: impl FnMut(&Hash256, u128),
    mut burn_fn: impl FnMut(u128),
) {
    let m = part_set_sorted.len();
    let drp = read_pool_balance();
    if drp == 0 || m == 0 { return; }
    let baseline = (drp * u128::from(DRP_BASELINE_PCT)) / 100;
    let lottery = drp - baseline;
    let per_base = baseline / (m as u128);
    let base_rem = baseline % (m as u128);
    let k = core::cmp::min(DRP_K_WINNERS, m);
    if k == 0 { return; }
    let winners_idx = pick_k_unique_indices(y_edge_s, s, m, k);
    let per_win = lottery / (k as u128);
    let lot_rem = lottery % (k as u128);
    if per_base == 0 && per_win == 0 { return; }
    let total_pay = per_base * (m as u128) + per_win * (k as u128);
    debit_pool(total_pay);
    if per_base > 0 {
        for pk in part_set_sorted { credit_pk(pk, per_base); }
    }
    if base_rem > 0 { burn_fn(base_rem); }
    if per_win > 0 {
        let mut winners: Vec<(usize, Hash256)> = winners_idx
            .iter()
            .map(|&i| (i, reward_rank(y_edge_s, &part_set_sorted[i])))
            .collect();
        winners.sort_by(|a, b| a.1.cmp(&b.1));
        for (idx, _rank) in winners { credit_pk(&part_set_sorted[idx], per_win); }
    }
    if lot_rem > 0 { burn_fn(lot_rem); }
}

// â€”â€”â€” System transaction (consensus wire) â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum SysTxKind { EscrowCredit=0, VerifierCredit=1, TreasuryCredit=2, Burn=3, RewardPayout=4, EmissionCredit=5 }

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub struct SysTx { pub kind: SysTxKind, pub slot: u64, pub pk: Hash256, pub amt: u128 }

#[derive(Debug, Error)]
pub enum SysTxCodecError { #[error("short")] Short, #[error("trailing")] Trailing }

const fn read_exact<'a>(src: &mut &'a [u8], n: usize) -> Result<&'a [u8], SysTxCodecError> { if src.len() < n { return Err(SysTxCodecError::Short); } let (a,b)=src.split_at(n); *src=b; Ok(a) }

#[must_use]
pub fn enc_sys_tx(tx: &SysTx) -> Vec<u8> {
    let mut out = Vec::new();
    out.extend_from_slice(&h_tag(constants::TAG_SYS_TX, &[]));
    out.extend_from_slice(&[tx.kind as u8]);
    out.extend_from_slice(&le_bytes::<8>(u128::from(tx.slot)));
    out.extend_from_slice(&tx.pk);
    out.extend_from_slice(&le_bytes::<16>(tx.amt));
    out
}

pub fn dec_sys_tx(mut src: &[u8]) -> Result<SysTx, SysTxCodecError> {
    let _tag = read_exact(&mut src, 32)?; // domain tag bytes
    let kind = {
        let b = read_exact(&mut src, 1)?[0];
        match b { 0=>SysTxKind::EscrowCredit,1=>SysTxKind::VerifierCredit,2=>SysTxKind::TreasuryCredit,4=>SysTxKind::RewardPayout,5=>SysTxKind::EmissionCredit,_=>SysTxKind::Burn }
    };
    let slot = u64::from_le_bytes(read_exact(&mut src, 8)?.try_into().unwrap());
    let pk = { let b = read_exact(&mut src, 32)?; let mut a=[0u8;32]; a.copy_from_slice(b); a };
    let amt = u128::from_le_bytes(read_exact(&mut src, 16)?.try_into().unwrap());
    if !src.is_empty() { return Err(SysTxCodecError::Trailing); }
    Ok(SysTx { kind, slot, pk, amt })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn emission_monotonic_and_terminal_assert() {
        let mut st = EmissionState::default();
        // Run a few slots to ensure no panic and monotonic emission.
        let mut total = 0u128;
        for s in 1u128..=1_000 { on_slot_emission(&mut st, s, |amt| { total = total.saturating_add(amt); }); }
        assert!(total > 0);
    }

    #[test]
    fn fee_rule_flat_and_percent() {
        assert_eq!(fee_int(10), FLAT_FEE_U);
        assert_eq!(fee_int(1_000), FLAT_FEE_U);
        assert_eq!(fee_int(1_001), 11);
    }

    #[test]
    fn escrow_split_respects_cap() {
        let mut fs = FeeSplitState::default();
        // Initialize epoch params deterministically
        nlb_roll_epoch_if_needed(0, &mut fs);
        fs.fee_escrow_u = 5; // low escrow to trigger cap logic
        // amount 100 â†’ fee rational 10/1, splits will try to release more than escrow
        route_fee_with_nlb(&mut fs, 10, 1, |_| {}, |_| {}, |_| {});
        assert!(fs.fee_escrow_u <= 5);
    }
}




crates>obex_alpha_t>tests>gating.rs
use obex_alpha_t::*;
use std::cell::RefCell;

#[test]
fn emission_runs_and_credits_total() {
    let mut st = EmissionState::default();
    let mut sum = 0u128;
    for s in 1u128..=1000 { on_slot_emission(&mut st, s, |amt| { sum = sum.saturating_add(amt); }); }
    assert!(sum > 0);
}

#[test]
fn escrow_conservation_basic() {
    let mut fs = FeeSplitState::default();
    let mut sent = 0u128;
    nlb_roll_epoch_if_needed(0, &mut fs);
    let (_, fee) = process_transfer(0, 10_000, 2_000, &mut fs, |_|{}, |_|{}, |f| { sent = sent.saturating_add(f); }, |_|{}, |_|{}, |_|{});
    assert!(fs.fee_escrow_u >= fee);
}

#[test]
fn route_fee_calls_in_order_and_not_overdraw() {
    let mut fs = FeeSplitState::default();
    nlb_roll_epoch_if_needed(0, &mut fs);
    fs.fee_escrow_u = 0; // start at zero
    // First accrue fee into escrow
    let mut escrow_credit_total = 0u128;
    let (_total, fee) = process_transfer(
        0,
        10_000,
        2_000,
        &mut fs,
        |_| {},
        |_| {},
        |f| { escrow_credit_total = escrow_credit_total.saturating_add(f); },
        |_| {},
        |_| {},
        |_| {},
    );
    assert!(fee > 0);
    assert_eq!(fs.fee_escrow_u, escrow_credit_total);

    // Now route releases and capture call order
    let calls: RefCell<Vec<&'static str>> = RefCell::new(Vec::new());
    let start_escrow = fs.fee_escrow_u;
    route_fee_with_nlb(
        &mut fs,
        10, // numerator
        1,  // denominator (flat)
        |v| { if v > 0 { calls.borrow_mut().push("verifier"); } },
        |t| { if t > 0 { calls.borrow_mut().push("treasury"); } },
        |b| { if b > 0 { calls.borrow_mut().push("burn"); } },
    );
    // Order must be verifier -> treasury -> burn when releases occur
    let calls_vec = calls.borrow().clone();
    if calls_vec.len() == 3 {
        assert_eq!(calls_vec, vec!["verifier", "treasury", "burn"]);
    }
    assert!(fs.fee_escrow_u <= start_escrow);
}



crates>obex_alpha_t>tests>golden.rs
#![allow(unused)]
use obex_alpha_t::{SysTx, SysTxKind, enc_sys_tx, dec_sys_tx};
use hex::ToHex;

#[test]
fn sys_tx_golden_roundtrip() {
    let tx = SysTx { kind: SysTxKind::RewardPayout, slot: 99, pk: [9u8;32], amt: 12345 };
    let b = enc_sys_tx(&tx);
    let tx2 = dec_sys_tx(&b).expect("decode");
    assert_eq!(tx2.slot, tx.slot);
    assert_eq!(tx2.kind as u8, tx.kind as u8);
    assert_eq!(tx2.amt, tx.amt);
    // Byte-for-byte re-encode equality
    let b2 = enc_sys_tx(&tx2);
    assert_eq!(b2, b);
    // Hex output exists for KAT dumps
    let _hex = b.encode_hex::<String>();
}



crates>obex_primitives>Cargo.toml
[package]
name = "obex_primitives"
version = "0.1.0"
edition = "2021"
license = "MIT OR Apache-2.0"
description = "Obex alpha primitives: hashing, encodings, Merkle, and utilities"
repository = "https://github.com/obex-labs/obex-alpha"
readme = "../../README.md"
keywords = ["obex","consensus","cryptography","merkle","vrf"]
categories = ["cryptography","algorithms","data-structures"]

[features]
default = ["std"]
std = ["sha3/std"]
alloc = []

[dependencies]
sha3 = { version = "0.10", default-features = false }
subtle = { version = "2.5", default-features = false }
thiserror = "2.0"

[dev-dependencies]
hex = "0.4"




crates>obex_primitives>src>constants.rs
#![forbid(unsafe_code)]

pub const GENESIS_PARENT_ID: [u8;32] = [0u8;32];
pub const TXROOT_GENESIS:   [u8;32] = [0u8;32];
pub const GENESIS_SLOT:      u64     = 0;

pub const TAG_MERKLE_LEAF:  &str = "obex.merkle.leaf";
pub const TAG_MERKLE_NODE:  &str = "obex.merkle.node";
pub const TAG_MERKLE_EMPTY: &str = "obex.merkle.empty";

pub const TAG_ALPHA:        &str = "obex.alpha";
pub const TAG_SEED:         &str = "obex.seed";
pub const TAG_L0:           &str = "obex.l0";
pub const TAG_LBL:          &str = "obex.lbl";
pub const TAG_IDX:          &str = "obex.idx";
pub const TAG_CHAL:         &str = "obex.chal";
pub const TAG_PART_LEAF:    &str = "obex.part.leaf";
pub const TAG_PARTREC:      &str = "obex.partrec";
pub const TAG_VRFY:         &str = "obex.vrfy";

pub const TAG_HEADER_ID:    &str = "obex.header.id";
pub const TAG_SLOT_SEED:    &str = "obex.slot.seed";
pub const TAG_VDF_YCORE:    &str = "obex.vdf.ycore";
pub const TAG_VDF_EDGE:     &str = "obex.vdf.edge";

pub const TAG_TX_ACCESS:    &str = "obex.tx.access";
pub const TAG_TX_BODY_V1:   &str = "obex.tx.body.v1";
pub const TAG_TX_ID:        &str = "obex.tx.id";
pub const TAG_TX_COMMIT:    &str = "obex.tx.commit";
pub const TAG_TX_SIG:       &str = "obex.tx.sig";
pub const TAG_TXID_LEAF:    &str = "obex.txid.leaf";
pub const TAG_TICKET_ID:    &str = "obex.ticket.id";
pub const TAG_TICKET_LEAF:  &str = "obex.ticket.leaf";

pub const TAG_SYS_TX:       &str = "obex.sys.tx";
pub const TAG_REWARD_DRAW:  &str = "obex.reward.draw";
pub const TAG_REWARD_RANK:  &str = "obex.reward.rank";




crates>obex_primitives>src>lib.rs
#![forbid(unsafe_code)]
#![deny(
    warnings,
    clippy::all,
    clippy::pedantic,
    clippy::nursery,
    clippy::cargo
)]
#![allow(
    clippy::module_name_repetitions,
    clippy::missing_errors_doc,
    clippy::missing_panics_doc,
    clippy::result_large_err
)]

//! Obex alpha primitives: hashing, fixed-width little-endian encodings, binary Merkle trees.
#![cfg_attr(not(feature = "std"), no_std)]
#[cfg(all(not(feature = "std"), feature = "alloc"))]
extern crate alloc;
//
// This crate implements the normative utilities shared across obex.Î± I/II/III/T:
//
// - Domain-tagged SHA3-256 with length framing
// - Fixed-width little-endian integer encodings
// - Binary Merkle (duplicate last when odd) and leaf verification
// - Constant-time equality helpers for 32-byte digests

use sha3::{Digest, Sha3_256};
use subtle::ConstantTimeEq;
#[cfg(feature = "std")]
use std::vec::Vec;
#[cfg(all(not(feature = "std"), feature = "alloc"))]
use alloc::vec::Vec;

/// 32-byte hash (SHA3-256 output).
pub type Hash256 = [u8; 32];

/// 32-byte public key (Ed25519).
pub type Pk32 = [u8; 32];

/// 64-byte signature (Ed25519 canonical encoding).
pub type Sig64 = [u8; 64];

pub mod constants;

/// Convert an unsigned integer to fixed-width little-endian bytes.
///
/// The output is exactly `W` bytes (no overlong encodings).
#[must_use]
pub fn le_bytes<const W: usize>(mut x: u128) -> [u8; W] {
    let mut out = [0u8; W];
    let mut i = 0usize;
    while i < W {
        out[i] = (x & 0xFF) as u8;
        x >>= 8;
        i += 1;
    }
    out
}

/// Read a `u64` from the first 8 bytes of a little-endian byte slice.
#[must_use]
pub fn u64_from_le(b: &[u8]) -> u64 {
    let mut x: u64 = 0;
    let mut i = 0usize;
    while i < 8 && i < b.len() {
        x |= u64::from(b[i]) << (8 * i as u64);
        i += 1;
    }
    x
}

/// Domain-tagged SHA3-256 with length framing as specified:
/// `H(tag_ascii, parts[])` = `SHA3_256`( UTF8(tag) || Î£ ( LE(|p|,8) || p ) )
#[must_use]
pub fn h_tag(tag: &str, parts: &[&[u8]]) -> Hash256 {
    let mut hasher = Sha3_256::new();
    hasher.update(tag.as_bytes());
    for p in parts {
        let len_le = le_bytes::<8>(p.len() as u128);
        hasher.update(len_le);
        hasher.update(p);
    }
    let digest = hasher.finalize();
    let mut out = [0u8; 32];
    out.copy_from_slice(&digest);
    out
}

/// Compute the Merkle leaf hash of a payload using the shared leaf domain tag.
#[must_use]
pub fn merkle_leaf(payload: &[u8]) -> Hash256 { h_tag(constants::TAG_MERKLE_LEAF, &[payload]) }

/// Compute the Merkle node hash from two child node hashes using the shared node domain tag.
#[must_use]
pub fn merkle_node(left: &Hash256, right: &Hash256) -> Hash256 {
    let mut cat = [0u8; 64];
    cat[..32].copy_from_slice(left);
    cat[32..].copy_from_slice(right);
    h_tag(constants::TAG_MERKLE_NODE, &[&cat])
}

/// Compute the binary Merkle root. When the number of nodes at a level is odd,
/// the last node is duplicated. The empty tree root is `H("obex.merkle.empty", [])`.
#[must_use]
pub fn merkle_root(leaves_payload: &[Vec<u8>]) -> Hash256 {
    if leaves_payload.is_empty() {
        return h_tag(constants::TAG_MERKLE_EMPTY, &[]);
    }
    let mut level: Vec<Hash256> = leaves_payload.iter().map(|p| merkle_leaf(p)).collect();
    while level.len() > 1 {
        if level.len() % 2 == 1 {
            if let Some(last) = level.last().copied() { level.push(last); }
        }
        let mut next: Vec<Hash256> = Vec::with_capacity(level.len() / 2);
        let mut i = 0usize;
        while i < level.len() {
            next.push(merkle_node(&level[i], &level[i + 1]));
            i += 2;
        }
        level = next;
    }
    // length >= 1
    level[0]
}

/// A Merkle authentication path for a leaf at `index`.
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct MerklePath {
    /// Sibling hashes from leaf to root.
    pub siblings: Vec<Hash256>,
    /// Leaf index in the tree (0-based).
    pub index: u64,
}

/// Verify a Merkle leaf payload against the supplied root with the given path.
#[must_use]
pub fn merkle_verify_leaf(root: &Hash256, leaf_payload: &[u8], path: &MerklePath) -> bool {
    let mut h = merkle_leaf(leaf_payload);
    let mut idx = path.index;
    for sib in &path.siblings {
        h = if idx & 1 == 0 { merkle_node(&h, sib) } else { merkle_node(sib, &h) };
        idx >>= 1;
    }
    ct_eq_hash(root, &h)
}

/// Constant-time equality for two 32-byte hashes.
#[must_use]
pub fn ct_eq_hash(a: &Hash256, b: &Hash256) -> bool { a.ct_eq(b).into() }

#[cfg(test)]
#[allow(
    clippy::too_many_lines,
    clippy::needless_pass_by_value,
    clippy::missing_panics_doc,
    clippy::missing_assert_message
)]
mod tests {
    use super::*;

    #[test]
    fn merkle_empty_matches_tag() {
        let empty = h_tag(constants::TAG_MERKLE_EMPTY, &[]);
        let root = merkle_root(&[]);
        assert!(ct_eq_hash(&empty, &root));
    }

    #[test]
    fn merkle_two_leaves_stable() {
        let leaves = vec![vec![0xAAu8; 3], vec![0xBBu8; 5]];
        let root = merkle_root(&leaves);
        // Determinism: second run yields the same root
        let root2 = merkle_root(&[vec![0xAAu8; 3], vec![0xBBu8; 5]]);
        assert!(ct_eq_hash(&root, &root2));
        // Sanity: root differs if leaf order changes
        let root_swapped = merkle_root(&[vec![0xBBu8; 5], vec![0xAAu8; 3]]);
        assert!(!ct_eq_hash(&root, &root_swapped));
    }
}




crates>obex_primitives>tests>kats.rs
use obex_primitives::{constants, h_tag};
use hex::ToHex;

#[test]
fn tag_digest_kats() {
    let kat = |tag: &str, exp_hex: &str| {
        let got = h_tag(tag, &[]).encode_hex::<String>();
        assert_eq!(got, exp_hex, "tag {tag}");
    };
    kat(constants::TAG_MERKLE_EMPTY, "2b254a1bacd43c5377c8fb2311066dee603ce5ed3e71321ab3ed2a3bb622857e");
    kat(constants::TAG_MERKLE_LEAF,  "3b9fd88425bc051fae7d0a4e9778227e80212baded982cf3bdab5ab5aa52ba06");
    kat(constants::TAG_MERKLE_NODE,  "07cbd406cb2ce8b3fea580928bf9d664557c4c0c72b3215ff67e27dc5a7d2253");
    kat(constants::TAG_ALPHA,        "883b7d61f4f9f4cc18d412eac66cfdb19bfbfc92383b0cd6e6e620a1f096070d");
    kat(constants::TAG_SEED,         "8023e13287b72bd669e5b9f92e0b342d164550b1537f7343644fde245310dd3a");
    kat(constants::TAG_L0,           "a09a3db5000604ee8a7ada47f2e7aafc30f805721b6b51d1c73a7204024e1435");
    kat(constants::TAG_LBL,          "e7d8c5c9cd0ce5b9bc63d205195514f827224e1aa34c913e5455c7791051c636");
    kat(constants::TAG_IDX,          "0425cbb72bd101e03d28889191b573a6beeb4e436ae78c498fc5c3f08a28ce7b");
    kat(constants::TAG_CHAL,         "75e1a47266a6659af16ddcc39ccb2a3347ffe015d658ce426f5a06208f89844d");
    kat(constants::TAG_PART_LEAF,    "55c4eedbdf5b4e8e8ffbd5fe2d47534617ba83c4bbb1d84a75cc931b33e3fad1");
    kat(constants::TAG_PARTREC,      "cc739c2a75978b7ce4c88d3b2925c24e40ce261a5731adcb4ca79608b50227c8");
    kat(constants::TAG_HEADER_ID,    "85d8423bb811d6c215b2cbc42568c38f00640759efd3a5416361c57f8b371b70");
    kat(constants::TAG_SLOT_SEED,    "ccce3774273f749084f50d7cb77d27ca122df9ec4135bee7bf17bbd139fa1306");
    kat(constants::TAG_VDF_YCORE,    "fbabaaa84a0027a961129fbb079d21c31f3ad94cb07967a9f083b765ca930842");
    kat(constants::TAG_VDF_EDGE,     "d8faf85e6942371bdaf0bbe3aac30dd4cfe80cb3aca5ba9b9563f35223b052dd");
    kat(constants::TAG_TX_ACCESS,    "c712fcfe14ad6ca1a72228ffea3bef61edd6b11d2a9391030877acf35981d4b7");
    kat(constants::TAG_TX_BODY_V1,   "f893dfbc8b6dbfe647bba7bfa57436b09da5ee3ee1c2b419fc66b29b0251fe6c");
    kat(constants::TAG_TX_ID,        "897313290c5dcfebf10f2af3bed98f21088d570651361f0d853b1614589a7a51");
    kat(constants::TAG_TX_COMMIT,    "aa907d27041c8f35765ef4057a1a41e715fb17f77e57382ce48112a49fd03853");
    kat(constants::TAG_TX_SIG,       "c85fb31b3b0e4b98cd31580a7e62603504c82c81ed7f97af52c4d41a3aee8628");
    kat(constants::TAG_TXID_LEAF,    "58cfb4815a8eb38c138190e429ad1abab996832795b1df0e48e6b4d769c9024c");
    kat(constants::TAG_TICKET_ID,    "5dc7f16b1caa7064713e809d985bb3ba77472748570c2b8c9757a557d4cd70e7");
    kat(constants::TAG_TICKET_LEAF,  "993238aeb220fefc409177e965a888c838a16063241d28330a11a33a42ca57d9");
    kat(constants::TAG_SYS_TX,       "3f422b0adf595d81bc5eee166404f365fd300ff13ba8429db776eeec9780d380");
    kat(constants::TAG_REWARD_DRAW,  "35a5e013fa37e8d90bae90c33dbf853916274223892c12448ac4bbe0e053ac4b");
    kat(constants::TAG_REWARD_RANK,  "3a066df4094f44a0a9b6f861fc2b10628e3f2f2e5bf39f433e45f6bba559e8d2");
}



crates>obex_primitives>tests>print_tags.rs
use obex_primitives::{constants, h_tag};
use hex::ToHex;

#[test]
fn print_tag_hex() {
    let tags = [
        constants::TAG_MERKLE_EMPTY,
        constants::TAG_MERKLE_LEAF,
        constants::TAG_MERKLE_NODE,
        constants::TAG_ALPHA,
        constants::TAG_SEED,
        constants::TAG_L0,
        constants::TAG_LBL,
        constants::TAG_IDX,
        constants::TAG_CHAL,
        constants::TAG_PART_LEAF,
        constants::TAG_PARTREC,
        constants::TAG_HEADER_ID,
        constants::TAG_SLOT_SEED,
        constants::TAG_VDF_YCORE,
        constants::TAG_VDF_EDGE,
        constants::TAG_TX_ACCESS,
        constants::TAG_TX_BODY_V1,
        constants::TAG_TX_ID,
        constants::TAG_TX_COMMIT,
        constants::TAG_TX_SIG,
        constants::TAG_TXID_LEAF,
        constants::TAG_TICKET_ID,
        constants::TAG_TICKET_LEAF,
        constants::TAG_SYS_TX,
        constants::TAG_REWARD_DRAW,
        constants::TAG_REWARD_RANK,
    ];
    for t in tags { println!("{}:{}", t, h_tag(t, &[]).encode_hex::<String>()); }
}




scripts>gen_superscript.ps1
Param(
    [string]$OutFile = "Superscript_obex_alphav1.txt"
)

$ErrorActionPreference = 'Stop'
$root = Get-Location

if (Test-Path -LiteralPath $OutFile) {
    Remove-Item -LiteralPath $OutFile -Force
}

Get-ChildItem -Recurse -File |
    Where-Object {
        $_.FullName -notlike (Join-Path $root.Path 'target\*') -and
        $_.FullName -ne (Join-Path $root.Path $OutFile)
    } |
    ForEach-Object {
        $rel = $_.FullName.Substring($root.Path.Length + 1)
        $pathFmt = $rel -replace '\\','>'
        $content = Get-Content -LiteralPath $_.FullName -Raw -ErrorAction SilentlyContinue
        if ($null -eq $content) { $content = '' }
        $entry = $pathFmt + ' ' + $content + [System.Environment]::NewLine + [System.Environment]::NewLine
        [System.IO.File]::AppendAllText($OutFile, $entry)
    }




