use obex_alpha_ii::{deserialize_header, obex_header_id, validate_header, BeaconInputs, BeaconVerifier, PartRootProvider, TicketRootProvider, TxRootProvider, OBEX_ALPHA_II_VERSION};
use obex_primitives::{constants, h_tag, le_bytes, Hash256};

struct BeaconOk;
impl BeaconVerifier for BeaconOk { fn verify(&self, _i: &BeaconInputs<'_>) -> bool { true } }
struct ZeroRoot;
impl TicketRootProvider for ZeroRoot { fn compute_ticket_root(&self, _slot: u64) -> Hash256 { [0u8;32] } }
impl PartRootProvider   for ZeroRoot { fn compute_part_root(&self, _slot: u64) -> Hash256 { [0u8;32] } }
impl TxRootProvider     for ZeroRoot { fn compute_txroot(&self, _slot: u64) -> Hash256 { [0u8;32] } }

#[test]
fn golden_header_accept_placeholder() {
    // Placeholder: use an empty header wire image for now; replace with committed golden file
    // once generated by the harness.
    let parent_id = [9u8; 32];
    let slot = 7u64;
    let seed_commit = h_tag(constants::TAG_SLOT_SEED, &[&parent_id, &le_bytes::<8>(slot as u128)]);
    let mut bytes = Vec::new();
    bytes.extend_from_slice(&parent_id);
    bytes.extend_from_slice(&le_bytes::<8>(u128::from(slot + 1)));
    bytes.extend_from_slice(&le_bytes::<4>(u128::from(OBEX_ALPHA_II_VERSION)));
    bytes.extend_from_slice(&seed_commit);
    bytes.extend_from_slice(&[2u8;32]); // vdf_y_core
    bytes.extend_from_slice(&[3u8;32]); // vdf_y_edge
    bytes.extend_from_slice(&le_bytes::<4>(0));
    bytes.extend_from_slice(&[]);
    bytes.extend_from_slice(&le_bytes::<4>(0));
    bytes.extend_from_slice(&[]);
    bytes.extend_from_slice(&[0u8;32]); // ticket_root
    bytes.extend_from_slice(&[0u8;32]); // part_root
    bytes.extend_from_slice(&[0u8;32]); // txroot_prev

    let h = deserialize_header(&bytes).expect("decode");
    let _id = obex_header_id(&h);
    let z = ZeroRoot; let b = BeaconOk;
    assert!(validate_header(&h, &h.clone(), &b, &z, &z, &z, OBEX_ALPHA_II_VERSION).is_err());
}


