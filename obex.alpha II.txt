obex.alpha II

obex.α II — Deterministic Header Engine (forkless by equalities)

Production blueprint (byte-precise, Rust-ready pseudocode).
Role: Build and validate the unique canonical header Header_s for slot s by checking pure equalities against deterministic commitments produced by other α-modules.
Consumes:
	•	From obex.α I: part_root_s (commitment to participation set P_s).
	•	From Beacon (VDF): y_edge_s plus canonical proof bytes (vdf_pi, vdf_ell).
	•	From obex.α III: ticket_root_s (admissions in s), txroot_{s-1} (executions in s−1).
Produces:
	•	Header_s and its immutable obex_header_id.
	•	Forklessness: at most one header satisfies all equalities for a fixed (parent, s).

All tags, field orders, lengths, and comparisons below are normative. Independent implementations MUST agree bit-for-bit.

⸻

1. Hashing, Encodings, and Merkle (normative)

Integers: little-endian fixed width only. LE(x, W) emits exactly W bytes (no overlong encodings).
Hash type: Hash256 = [u8; 32].

Domain-tagged SHA3-256 with length framing (global discipline):

H(tag_ascii, parts[]) =
    SHA3_256( UTF8(tag_ascii) || Σ ( LE(|p|,8) || p ) )

Binary Merkle (duplicate last when odd):
	•	Leaf: H("obex.merkle.leaf", payload)
	•	Node: H("obex.merkle.node", L || R)
	•	Empty: H("obex.merkle.empty", [])

Canonical leaf payload tags used by α II:

"obex.txid.leaf"    // leaves over executed txids
"obex.ticket.leaf"  // leaves over TicketRecords (α III)

Header/Beacon/Seed tags used by α II:

"obex.header.id"   "obex.slot.seed"   "obex.vdf.ycore"   "obex.vdf.edge"

Any byte change to tag strings alters consensus. These ASCII tags are exact.

⸻

2. Consensus Constants

OBEX_ALPHA_II_VERSION = 2      // includes part_root field and obex.* tag space

OBEX_ALPHA_II_VERSION MUST be enforced at validation time.

⸻

3. Inter-Module Coherence (deterministic providers)
	•	Beacon (VDF)
Canonical seed for slot s:

seed_s = H("obex.slot.seed", [ parent_id, LE(s,8) ])

The beacon adapter verifies the backend proof and returns:
	•	vdf_y_core = H("obex.vdf.ycore", [ Y_raw ])
	•	vdf_y_edge = H("obex.vdf.edge",  [ vdf_y_core ])
plus bounded byte arrays (vdf_pi, vdf_ell).

	•	obex.α I (Participation)
Verifier recomputes P_s and part_root_s from ObexPartRecs for target slot s. (α II only consumes part_root_s.)
	•	obex.α III (Admission/Execution)
Deterministically recompute:
	•	ticket_root_s from canonical TicketRecord set for s.
	•	txroot_{s-1} from executed txids of s−1.

α II does not execute or admit; it only validates equalities against these deterministic results.

⸻

4. Header Object (canonical fields & order)

Header {
  parent_id         : Hash256         // == obex_header_id(parent)
  slot              : u64             // == parent.slot + 1
  obex_version      : u32             // == OBEX_ALPHA_II_VERSION

  // Beacon commitments (VDF)
  seed_commit       : Hash256         // == H("obex.slot.seed",[parent_id, LE(slot,8)])
  vdf_y_core        : Hash256         // == H("obex.vdf.ycore", [Y_raw])
  vdf_y_edge        : Hash256         // == H("obex.vdf.edge", [vdf_y_core])
  vdf_pi            : Bytes           // opaque; length-prefixed
  vdf_ell           : Bytes           // opaque; length-prefixed

  // Deterministic commitments (other α modules)
  ticket_root       : Hash256         // α III (slot s)
  part_root         : Hash256         // α I   (slot s)
  txroot_prev       : Hash256         // α III (slot s-1)
}

4.1 Wire serialization (normative layout)

serialize_header(h):
  bytes = []
  bytes += h.parent_id                        // 32
  bytes += LE(h.slot,8)                       // 8
  bytes += LE(h.obex_version,4)               // 4

  bytes += h.seed_commit                      // 32
  bytes += h.vdf_y_core                       // 32
  bytes += h.vdf_y_edge                       // 32
  bytes += LE(|h.vdf_pi|,4)  || h.vdf_pi[..]  // 4 + |pi|
  bytes += LE(|h.vdf_ell|,4) || h.vdf_ell[..] // 4 + |ell|

  bytes += h.ticket_root                      // 32
  bytes += h.part_root                        // 32
  bytes += h.txroot_prev                      // 32

4.2 Immutable header ID (consensus identity)

obex_header_id(h) = H("obex.header.id", [
  h.parent_id,
  LE(h.slot,8),
  LE(h.obex_version,4),

  h.seed_commit, h.vdf_y_core, h.vdf_y_edge,
  LE(|h.vdf_pi|,4),  h.vdf_pi,
  LE(|h.vdf_ell|,4), h.vdf_ell,

  h.ticket_root,
  h.part_root,
  h.txroot_prev
])

The ID is over field values, not the transport bytes, and is therefore stable across encoders that obey §4.1.

⸻

5. Validity Equalities (all MUST hold)

For candidate header h and known parent:
	1.	Parent linkage & slot progression
	•	h.parent_id == obex_header_id(parent)
	•	h.slot      == parent.slot + 1
	2.	Beacon equality & size caps (via adapter)
	•	h.seed_commit == H("obex.slot.seed",[h.parent_id, LE(h.slot,8)])
	•	beacon.verify(h.parent_id, h.slot, h.seed_commit, h.vdf_y_core, h.vdf_y_edge, h.vdf_pi, h.vdf_ell) returns true and enforces |vdf_pi| ≤ MAX_PI_LEN, |vdf_ell| ≤ MAX_ELL_LEN.
	3.	Admission equality (slot s via α III)
	•	h.ticket_root == ticket_roots.compute_ticket_root(h.slot)
	4.	Participation equality (slot s via α I)
	•	h.part_root == part_roots.compute_part_root(h.slot)
	5.	Execution equality (slot s−1 via α III)
	•	h.txroot_prev == tx_roots.compute_txroot(h.slot − 1)
	•	For genesis slot S0: h.txroot_prev == TXROOT_GENESIS (constant).
	6.	Version equality
	•	h.obex_version == OBEX_ALPHA_II_VERSION

Any failure ⇒ header invalid. Since all RHS values are unique deterministic functions of (parent, s), at most one Header_s can satisfy all equalities (forklessness).

⸻

6. Rust-Ready Module (byte-precise pseudocode)

Replace sha3_256 and the beacon adapter with real implementations. All encodings and field orders are normative.

// ========================= obex_alpha_ii.rs ==========================
// obex.α II — Deterministic Header Engine (forkless by equalities)
// ====================================================================

#![allow(unused)]
use alloc::vec::Vec;

// ——— Types ———————————————————————————————————————————————————————
pub type Hash256 = [u8; 32];

// ——— Integer encodings ———————————————————————————————————————————
#[inline]
pub fn le_bytes<const W: usize>(mut x: u128) -> [u8; W] {
    let mut out = [0u8; W];
    for i in 0..W { out[i] = (x & 0xFF) as u8; x >>= 8; }
    out
}

// ——— Hashing (domain-tagged, length-framed) ————————————————
pub fn sha3_256(_input: &[u8]) -> Hash256 { unimplemented!() }

#[inline]
pub fn h_tag(tag: &str, parts: &[&[u8]]) -> Hash256 {
    let mut buf = Vec::new();
    buf.extend_from_slice(tag.as_bytes());
    for p in parts {
        buf.extend_from_slice(&le_bytes::<8>(p.len() as u128));
        buf.extend_from_slice(p);
    }
    sha3_256(&buf)
}

// ——— Merkle helpers (shared tags) ————————————————————————————
#[inline] pub fn merkle_leaf(payload: &[u8]) -> Hash256 { h_tag("obex.merkle.leaf", &[payload]) }
#[inline]
pub fn merkle_node(l: &Hash256, r: &Hash256) -> Hash256 {
    let mut cat = [0u8; 64];
    cat[..32].copy_from_slice(l);
    cat[32..].copy_from_slice(r);
    h_tag("obex.merkle.node", &[&cat])
}
pub fn merkle_root(leaves_payload: &[Vec<u8>]) -> Hash256 {
    if leaves_payload.is_empty() { return h_tag("obex.merkle.empty", &[]); }
    let mut lvl: Vec<Hash256> = leaves_payload.iter().map(|p| merkle_leaf(p)).collect();
    while lvl.len() > 1 {
        if lvl.len() % 2 == 1 { lvl.push(*lvl.last().unwrap()); }
        let mut nxt = Vec::with_capacity(lvl.len()/2);
        for i in (0..lvl.len()).step_by(2) { nxt.push(merkle_node(&lvl[i], &lvl[i+1])); }
        lvl = nxt;
    }
    lvl[0]
}

// ——— Providers (adapters) ——————————————————————————————————————
// Beacon (VDF) equality checker + caps
pub trait BeaconVerifier {
    /// Returns true iff:
    ///   seed_commit == H("obex.slot.seed",[parent_id, LE(slot,8)]) &&
    ///   backend proof verifies (reconstructs canonical Y_raw) &&
    ///   vdf_y_core == H("obex.vdf.ycore", [Y_raw]) &&
    ///   vdf_y_edge == H("obex.vdf.edge",  [vdf_y_core]) &&
    ///   |vdf_pi| ≤ MAX_PI_LEN, |vdf_ell| ≤ MAX_ELL_LEN
    fn verify(
        &self,
        parent_id: &Hash256,
        slot: u64,
        seed_commit: &Hash256,
        vdf_y_core:  &Hash256,
        vdf_y_edge:  &Hash256,
        vdf_pi:      &[u8],
        vdf_ell:     &[u8],
    ) -> bool;
}

pub trait TicketRootProvider {
    /// Deterministically compute ticket_root for slot `slot` from canonical TicketRecords (α III):
    ///   - sort by txid ascending (raw bytes)
    ///   - leaf payload = H("obex.ticket.leaf",[]) || fields...
    ///   - return binary Merkle root
    fn compute_ticket_root(&self, slot: u64) -> Hash256;
}
pub trait PartRootProvider {
    /// Deterministically compute part_root for slot `slot` from α I:
    ///   - build P_s (sorted PKs)
    ///   - leaf payload = H("obex.part.leaf",[]) || pk
    ///   - return binary Merkle root
    fn compute_part_root(&self, slot: u64) -> Hash256;
}
pub trait TxRootProvider {
    /// Deterministically compute txroot for slot `slot` over executed txids (α III):
    ///   - sort txids ascending
    ///   - leaf payload = H("obex.txid.leaf",[]) || txid
    ///   - return binary Merkle root
    fn compute_txroot(&self, slot: u64) -> Hash256;
}

// ——— Constants ———————————————————————————————————————————————
pub const OBEX_ALPHA_II_VERSION: u32 = 2;

// ——— Header struct & canonical ID ————————————————————————————
#[derive(Clone)]
pub struct Header {
    pub parent_id:         Hash256,
    pub slot:              u64,
    pub obex_version:      u32,

    // Beacon (VDF)
    pub seed_commit:       Hash256,
    pub vdf_y_core:        Hash256,
    pub vdf_y_edge:        Hash256,
    pub vdf_pi:            Vec<u8>,  // len-prefixed on the wire
    pub vdf_ell:           Vec<u8>,  // len-prefixed on the wire

    // Deterministic commitments
    pub ticket_root:       Hash256,  // slot s
    pub part_root:         Hash256,  // slot s
    pub txroot_prev:       Hash256,  // slot s-1
}

pub fn obex_header_id(h: &Header) -> Hash256 {
    h_tag("obex.header.id", &[
        &h.parent_id,
        &le_bytes::<8>(h.slot as u128),
        &le_bytes::<4>(h.obex_version as u128),

        &h.seed_commit,
        &h.vdf_y_core,
        &h.vdf_y_edge,
        &le_bytes::<4>(h.vdf_pi.len() as u128),  &h.vdf_pi,
        &le_bytes::<4>(h.vdf_ell.len() as u128), &h.vdf_ell,

        &h.ticket_root,
        &h.part_root,
        &h.txroot_prev,
    ])
}

// ——— Builder & Validator ———————————————————————————————————————
pub enum BuildErr { /* reserved: provider failures */ }

pub enum ValidateErr {
    BadParentLink,
    BadSlotProgression,
    BeaconInvalid,
    TicketRootMismatch,
    PartRootMismatch,
    TxRootPrevMismatch,
    VersionMismatch,
}

pub fn build_header(
    parent: &Header,
    beacon_fields: (Hash256, Hash256, Hash256, Vec<u8>, Vec<u8>), // (seed_commit, y_core, y_edge, pi, ell)
    ticket_roots: &impl TicketRootProvider,
    part_roots:   &impl PartRootProvider,
    tx_roots:     &impl TxRootProvider,
    obex_version: u32,
) -> Result<Header, BuildErr> {
    let s = parent.slot + 1;
    let (seed_commit, y_core, y_edge, pi, ell) = beacon_fields;

    let ticket_root = ticket_roots.compute_ticket_root(s);
    let part_root   = part_roots.compute_part_root(s);
    let txroot_prev = tx_roots.compute_txroot(parent.slot);

    Ok(Header {
        parent_id: obex_header_id(parent),
        slot: s,
        obex_version,
        seed_commit,
        vdf_y_core: y_core,
        vdf_y_edge: y_edge,
        vdf_pi: pi,
        vdf_ell: ell,
        ticket_root,
        part_root,
        txroot_prev,
    })
}

pub fn validate_header(
    h: &Header,
    parent: &Header,
    beacon: &impl BeaconVerifier,
    ticket_roots: &impl TicketRootProvider,
    part_roots:   &impl PartRootProvider,
    tx_roots:     &impl TxRootProvider,
    expected_version: u32,
) -> Result<(), ValidateErr> {
    // 1) Parent linkage & slot progression
    if h.parent_id != obex_header_id(parent) { return Err(ValidateErr::BadParentLink); }
    if h.slot != parent.slot + 1 { return Err(ValidateErr::BadSlotProgression); }

    // 2) Beacon equality & caps
    if !beacon.verify(
        &h.parent_id, h.slot,
        &h.seed_commit, &h.vdf_y_core, &h.vdf_y_edge,
        &h.vdf_pi, &h.vdf_ell,
    ) { return Err(ValidateErr::BeaconInvalid); }

    // 3) Admission equality (slot s)
    let ticket_root_local = ticket_roots.compute_ticket_root(h.slot);
    if h.ticket_root != ticket_root_local { return Err(ValidateErr::TicketRootMismatch); }

    // 4) Participation equality (slot s)
    let part_root_local = part_roots.compute_part_root(h.slot);
    if h.part_root != part_root_local { return Err(ValidateErr::PartRootMismatch); }

    // 5) Execution equality (slot s-1)
    let txroot_prev_local = tx_roots.compute_txroot(parent.slot);
    if h.txroot_prev != txroot_prev_local { return Err(ValidateErr::TxRootPrevMismatch); }

    // 6) Version equality
    if h.obex_version != expected_version { return Err(ValidateErr::VersionMismatch); }

    Ok(())
}


⸻

7. Pipeline (exact order; per slot s)

Finality window (0–100 ms of slot s):
	1.	Beacon: compute seed_s = H("obex.slot.seed",[parent_id, LE(s,8)]); producers supply (Y_raw, vdf_pi, vdf_ell). Validators call beacon.verify(…) which enforces all beacon equalities and size caps and returns vdf_y_core, vdf_y_edge.
	2.	Admission (α III): deterministically build ticket_root_s.
	3.	Participation (α I): deterministically build part_root_s.
	4.	Execution lag-1 (α III): deterministically build txroot_{s-1}.
	5.	α II: build Header_s, validate locally (validate_header) before gossip/commit. Only one header can satisfy all equalities.

Settlement window (100–1000 ms of slot s):
Executor processes admitted transactions for s and produces txroot_s to be committed by Header_{s+1}.

⸻

8. Genesis & Edge Cases
	•	Genesis header for slot S0:
	•	parent_id = GENESIS_PARENT_ID (constant)
	•	slot = S0
	•	seed_commit = H("obex.slot.seed",[GENESIS_PARENT_ID, LE(S0,8)])
	•	txroot_prev = TXROOT_GENESIS (constant)
	•	ticket_root = H("obex.merkle.empty",[]) if no admissions
	•	part_root   = H("obex.merkle.empty",[]) if no participants
	•	Beacon fields produced for (seed_commit, VDF_DELAY_T).
	•	Empty sets: providers MUST return H("obex.merkle.empty",[]) for empty lists.
	•	Deserialization: network decoders MUST enforce exact field order and lengths as in §4.1 and reject any deviation or truncation.

⸻

9. DoS Hardening & Determinism
	•	Only vdf_pi and vdf_ell are variable-length; the beacon adapter MUST enforce size caps before cryptographic work.
	•	All other fields are fixed-width and must be range-checked.
	•	Sorting rules for ticket/txid/participation sets are strict byte-lexicographic order.
	•	All 32-byte hash comparisons and parent link checks SHOULD be constant-time.

⸻

10. Formal Forklessness Sketch

Fix (parent, s). The following are unique deterministic functions:

seed_s        = H("obex.slot.seed",[parent_id, LE(s,8)])
(vdf_y_core, vdf_y_edge, vdf_pi, vdf_ell)  = Beacon(seed_s)  // or reject by verify()
ticket_root_s = αIII.TicketRoot(s)
part_root_s   = αI.PartRoot(s)
txroot_{s-1}  = αIII.TxRoot(s-1)

Therefore the unique valid header is:

Header_s = (
  parent_id=obex_header_id(parent), slot=s, obex_version=OBEX_ALPHA_II_VERSION,
  seed_commit=seed_s, vdf_y_core, vdf_y_edge, vdf_pi, vdf_ell,
  ticket_root=ticket_root_s, part_root=part_root_s, txroot_prev=txroot_{s-1}
)

Any competitor differs in at least one field and fails a validity equality.

⸻

11. Conformance Checklist (engineer-facing)
	•	Integers are LE fixed-width; vector lengths are LE(4).
	•	Tags used exactly: "obex.header.id", "obex.slot.seed", "obex.vdf.ycore", "obex.vdf.edge", "obex.txid.leaf", "obex.ticket.leaf", "obex.merkle.*".
	•	serialize_header field order is exact; only vdf_pi / vdf_ell are length-prefixed.
	•	obex_header_id computed over field values as in §4.2.
	•	Parent linkage and slot = parent.slot + 1 enforced.
	•	Beacon adapter enforces all equalities and size caps.
	•	ticket_root_s, part_root_s, and txroot_{s-1} recomputed locally and compared.
	•	obex_version == OBEX_ALPHA_II_VERSION.
	•	Constant-time comparisons for 32-byte digests.

⸻

12. Test Vectors (ship with implementations)
	1.	Nominal header
	•	Given: full parent, slot = parent.slot + 1, concrete beacon backend outputs, canonical α I/α III sets.
	•	Output: Header_s, serialize_header(h), obex_header_id(h) (all hex).
	2.	Parent link failure → BadParentLink.
	3.	Slot progression failure → BadSlotProgression.
	4.	Beacon mismatch (flip 1 byte in vdf_y_core) → BeaconInvalid.
	5.	Ticket root mismatch (shuffle TicketRecords) → TicketRootMismatch.
	6.	Participation root mismatch (omit a PK) → PartRootMismatch.
	7.	Txroot lag-1 mismatch (modify executed set) → TxRootPrevMismatch.
	8.	Version mismatch → VersionMismatch.
	9.	Empty sets → both roots equal H("obex.merkle.empty",[]).

⸻

13. Public API Summary

build_header(
    parent: &Header,
    beacon_fields: (Hash256, Hash256, Hash256, Vec<u8>, Vec<u8>),
    ticket_roots: &impl TicketRootProvider,
    part_roots:   &impl PartRootProvider,
    tx_roots:     &impl TxRootProvider,
    obex_version: u32,
) -> Result<Header, BuildErr>

validate_header(
    h: &Header,
    parent: &Header,
    beacon: &impl BeaconVerifier,
    ticket_roots: &impl TicketRootProvider,
    part_roots:   &impl PartRootProvider,
    tx_roots:     &impl TxRootProvider,
    expected_version: u32,
) -> Result<(), ValidateErr>

These two functions, together with the normative hashing/encoding rules and the α I/α III providers, are sufficient for full obex.α II consensus integration.

⸻

This obex.α II blueprint is complete and byte-precise.
It specifies exact encodings, deterministic equalities, a canonical header identity, and a strict validator path. Implementations adhering to this document will agree bit-for-bit on header validity and identity for every slot.